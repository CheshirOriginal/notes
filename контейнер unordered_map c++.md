Воспользуемся другой реализацией ассоциативного массива из стандартной библиотеки C++ — хеш-таблицей [`unordered_map`](https://en.cppreference.com/w/cpp/container/unordered_map). Само название этого класса подчёркивает, что данные будут храниться не упорядоченными по ключу. Предполагается, что для каждого ключа определена хеш-функция (по умолчанию [`std::hash<Key>()`](https://en.cppreference.com/w/cpp/utility/hash)), а по ней вычисляется номер _корзины_ (bucket), в которую должен попасть ключ.

Случай, когда два разных ключа оказываются в одной корзине, называется _коллизией_. В С++ для разрешения коллизий используется [_метод цепочек_](https://en.wikipedia.org/wiki/Hash_table#Collision_resolution), то есть, внутри одной корзины все элементы выстраиваются в односвязный список.

Если хеш-функция достаточно равномерна и корзин достаточно много, то в среднем время поиска, добавления и удаления элементов для `unordered_map` будет _константным_ O(1).

Интерфейс `unordered_map` специально сделан похожим на интерфейс `map`.

У контейнера `unordered_map` есть функция [`max_load_factor`](https://en.cppreference.com/w/cpp/container/unordered_map/max_load_factor), которая задаёт максимально допустимое соотношение между числом элементов и количеством корзин. По умолчанию эта величина равна единице, так что `unordered_map` пытается _в среднем_ вообще избежать коллизий. Но это не означает отсутствия коллизий в отдельных корзинах.

Если при вставке очередного элемента среднее число элементов в корзинах превышает этот порог, число корзин автоматически увеличивается и происходит _рехеширование_. Чем-то это напоминает реаллокацию у вектора.

Если нам заранее известно финальное количество ключей, то можно вызвать заранее функцию [`reserve`](https://en.cppreference.com/w/cpp/container/unordered_map/reserve) и избежать лишних рехеширований при вставках. Тем самым можно отыграть дополнительное время.

