Структура — это тип, содержащий именованные поля. Например, мы можем представить круг таким образом:

```go
type Circle struct {
    x float64
    y float64
    r float64
}
```

Ключевое слово `type` вводит новый тип. За ним следует имя нового типа `Circle` и ключевое слово `struct`, которое говорит, что мы определяем структуру и список полей внутри фигурных скобок. Каждое поле имеет имя и тип. Как и с функциями, мы можем объединять поля одного типа:  
 

```go
type Circle struct {
    x, y, r float64
}
```

### Инициализация

Мы можем создать экземпляр нового типа `Circle` несколькими способами:

```go
var c Circle
// или
c := Circle{}
```

Подобно другим типам данных, будет создана локальная переменная типа `Circle`, чьи поля по умолчанию будут равны нулю (`0` для `int`, `0.0` для `float`, `""` для `string`, `nil` для указателей, …). Также, для создания экземпляра можно использовать функцию `new`.

```go
c := new(Circle) // возвращается указатель на пустую структуру 
```

Это выделит память для всех полей, присвоит каждому из них нулевое значение и вернет указатель (`*Circle`). Часто, при создании структуры мы хотим присвоить полям структуры какие-нибудь значения. Существует два способа сделать это. Первый способ:

```go
c := Circle{x: 0, y: 0, r: 5}
```

Второй способ — мы можем опустить имена полей, если мы знаем порядок в котором они определены:  
 
```go
c := Circle{0, 0, 5}
```

### Поля

Получить доступ к полям можно с помощью оператора `.` (точка):

```go
fmt.Println(c.x, c.y, c.r)
c.x = 10
c.y = 5
```

### Методы

Несмотря на то, что программа стала лучше, мы все еще можем значительно её улучшить, используя метод — функцию особого типа:

```go
func (c *Circle) area() float64 {
    return math.Pi * c.r * c.r
}
```

Между ключевым словом `func` и именем функции мы добавили «получателя». Получатель похож на параметр — у него есть имя и тип, но объявление функции таким способом позволяет нам вызывать функцию с помощью оператора `.`:

```go
fmt.Println(c.area())
```

Это гораздо проще прочесть, нам не нужно использовать оператор `&` (Go автоматически предоставляет доступ к указателю на `Circle` для этого метода), и поскольку эта функция может быть использована только для `Circle` мы можем назвать её просто `area`.

### Встраиваемые типы

Предположим, у нас есть структура `Person` (личность):

```go
type Person struct {
    Name string
}
func (p *Person) Talk() {
    fmt.Println("Hi, my name is", p.Name)
}
```

И если мы хотим создать новую структуру `Android`, то можем сделать так:

```go
type Android struct {
    Person Person
    Model string
}
```

Это будет работать, но мы можем захотеть создать другое отношение. Сейчас у андроида «есть» личность, можем ли мы описать отношение андроид «является» личностью? Go поддерживает подобные отношения с помощью ==встраиваемых типов, также называемых анонимными полями.== Выглядят они так:

```go
type Android struct {
    Person
    Model string
}
```

Мы использовали тип (`Person`) и не написали его имя. Объявленная таким способом структура доступна через имя типа:

```go
a := new(Android)
a.Person.Talk()
```

Но мы также можем вызвать любой метод `Person` прямо из `Android`:

```go
a := new(Android)
a.Talk()
```

Это отношение работает достаточно интуитивно: личности могут говорить, андроид это личность, значит андроид может говорить.  
  
Также мы можем при создании инициализировать нужные переменные:

```go
var a = Android{
	Model: "model",
	Person: Person {
		Name: "name",
	},
}
```

==Итог: это что то вроде наследования, новая структура перенимает поля и методы встраиваемой. ==

