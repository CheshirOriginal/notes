Если контейнер изменяется, то в некоторых случаях итераторы и ссылки (указатели) на элементы могут стать [невалидными](https://en.cppreference.com/w/cpp/container#Iterator_invalidation).  
Рассмотрим пример:

```c++
#include <iostream>
#include <vector>

int main() {
    std::vector<int> v = {1, 2, 3, 4};

    auto iter = v.begin();  // итератор
    int* ptr = &v.front();  // указатель
    int& ref = v.front();  // ссылка

    std::cout << *iter << " " << *ptr << " " << ref << "\n";  // 1 1 1

    v.push_back(5);  // происходит реаллокация

    // обращаться к старым итераторам, указателям и ссылкам больше нельзя:
    std::cout << *iter << " " << *ptr << " " << ref << "\n";  // неопределённое поведение!
}
```

==В этом примере показано, что итераторы, указатели или ссылки могут оказаться невалидными, если у вектора произошла реаллокация.== Рассмотрим, как ведут себя итераторы других последовательных контейнеров при добавлении элементов в конец. Указатели и ссылки тут либо вместе инвалидируются, либо вместе остаются валидными, так как они в конечном итоге смотрят на память, которую занимал элемент.

1. Строка `std::string` ведёт себя так же, как и вектор: все итераторы и ссылки инвалидируются.
2. В `std::array` ничего вставить нельзя, его размер фиксирован.
3. В `std::deque` инвалидируются итераторы, но не инвалидируются ссылки и указатели! Сами элементы дека остаются в тех же местах памяти, но во внутреннем векторе страниц, про который должен знать итератор дека, вообще говоря, может произойти реаллокация.
4. В `std::list` и `std::forward_list` ни итераторы, ни ссылки не инвалидируются. Так что если в приведённом примере заменить `vector` на `list`, то он будет корректно работать.

Валидность итераторов и ссылок после вызова той или иной функции контейнера описывается в документации (вот [пример](https://en.cppreference.com/w/cpp/container/vector/push_back) для `push_back` у вектора). Также можно обратиться к [этой таблице](https://en.cppreference.com/w/cpp/container#Iterator_invalidation).