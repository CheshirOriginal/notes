[[Язык GoLang]]

Интерфейс представляет из себя контракт, определяющий методы, которым обязан обладать объект, удовлетворяющий интерфейсу.
### Объявление интерфейса

Интерфейсы, как и другие типы в Go, объявляются с помощью ключевого слова type, за которым следует имя объявляемого типа, а за ним - базовый тип (в нашем случае - interface). В фигурных скобках указаны имена и описания методов, которые должен иметь объект, чтобы "удовлетворять" данному интерфейсу. Реализация методов может быть совершенно разной, важно само наличие метода с соответствующим описанием (принимаемые аргументы и возвращаемые значения).

Посмотрим как объявляется интерфейс:

```go
type Reader interface {
	Read(p []byte) (n int, err error)
}

type Writer interface {
	Write(p []byte) (n int, err error)
}
```

Объекты, удовлетворяющие интерфейсу `Reader`, имеют метод `Read`, который получает срез байт (буфер, в который производится чтение) в качестве аргумента, а возвращает количество прочитанных байт и сообщение об ошибке. Интерфейс `Writer` делает все наоборот: его метод `Write` получает срез байт (буфер, из которого производится чтение), возвращает количество записанных байт и сообщение об ошибке.

#### Утиная типизация

==В Go интерфейс реализуется неявно. Нам не надо специально указывать, что структуры применяют определенный интерфейс, как в некоторых других языках программирования. Для реализации типу данных достаточно реализовать методы, которые определяет интерфейс (если что то похоже на утку - это утка).== Пример:

```go
type Vehicle interface{
    move()
}

// структура "Автомобиль"

type Car struct { }

func (c Car) move() {
    fmt.Println("Автомобиль едет")
}

func main() {
    var tesla Vehicle = Car{}
    tesla.move()
}
```

Другой пример:

```go
type Vehicle interface{
    move()
}

// структура "Автомобиль"

type Car struct { }

func (c *Car) move() { // в даном случае мы реализуем метод интерфейса для
//типа *Car а не Car, как в предыдущем случае
    fmt.Println("Автомобиль едет")
}

func main() {
    var tesla Vehicle = &Car{} // переменной типа Vehicle мы можем присвоить указатель на структуру *Car, а не саму струтктуру Car
    //var tesla Vehicle = Car{} - будет ошибкой
    tesla.move()
}
```
### Реализация нескольких интерфейсов

Тип данных необязательно должен реализовать только методы интерфейса, для типа данных можно определить его собственные методы или также реализовать методы других интерфейсов (нескольких интерфейсов).
### Встраивание интерфейса

Стиль программирования на Go предполагает, что чем более четко мы сформулируем задачу, тем меньше вероятность возникновения ошибки. Таким образом (я продолжу использовать для примера интерфейсы из пакета io), если мы хотим использовать функцию лишь для чтения данных, то разумно использовать в качестве аргумента интерфейс io.Reader, а если для записи, то io.Writer.

Вместе с тем, Go позволяет нам совмещать интерфейсы, чтобы показать, что объект должен удовлетворять обоим интерфейсам. Это реализуется через создание нового интерфейса, в который требуемые нам интерфейсы встраиваются:

```go
type ReadWriter interface {
    Reader  // это io.Reader
    Writer  // это io.Writer
}
```

Таким образом Go будет проверять, что у объекта есть методы обязательные для обоих интерфейсов: Read и Write.

_Обратите внимание на используемые имена интерфейсов: в Go считается правильным называть интерфейс через имя его методов с добавлением суффикса -er, а если таких методов несколько, использовать имена всех методов._
### Пустой интерфейс

Интерфейс, который не содержит ни одного метода называется пустым интерфейсом: interface{}. Пустой интерфейс может содержать значение любого типа. Пустые интерфейсы используются в коде, где необходимо работать со значениями неизвестного типа. Например, `fmt.Print()` принимает любое количество аргументов типа interface{}.
## Приведение типа

Приведение типа позволяет нам получить внутреннее значение интерфейса, в полной мере это реализуется следующим образом:

```go
// Конструкция приведения типа:
// t, ok := i.(T)

// Пример:
var i interface{} = 12

if v, ok := i.(int); ok {
	fmt.Println(v+12) // Суммирование не произойдет, если ok == false
}
```

Здесь t значение, приведенное к типу T, а i - исходное значение интерфейсного типа. ok - логическое значение, показывающее успешность приведения типа: true - все удачно, false - использование t приведет к панике. Значение ok может быть опущено, но будьте аккуратны с этим.

Но что делать, если мы не знаем типа объекта, лежащего внутри интерфейса? Тогда мы можем воспользоваться конструкцией, называемой переключателем типов, выглядит она следующим образом:

```go
switch v := i.(type) {
	case T1:
		...
	case T2, T3:
		...
	default:
		...
}
```

Возьмем теперь такой пример:

```go
package main

import "fmt"

func do(i interface{}) {
	switch v := i.(type) {
	case int:
		fmt.Println("Умножим на 2:", v*2)
	case string:
		fmt.Println(v + " golang")
	default:
		fmt.Printf("Я не знаю такого типа %T!\n", v)
	}
}

func main() {
	do(21)
	do("hello")
	do(true)
}
```

Вывод будет таким:

```
Умножим на 2: 42
hello golang
Я не знаю такого типа bool!
```

[[Ортогональность интерфейсов в go]]
[[Устройство интерфейсов в go]]
[[Как перестать абьюзить интерфейсы и начать жить go]]




