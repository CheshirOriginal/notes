Map в Go представляет собой ссылку на хеш-таблицу, а его тип записывается как `map[K]V`, где К и V являются типами его ключей и значений.

### Создание map

```go
// с помощью встроенной функции make:
m1 := make(map[int]int) // [] - ключ /  значение 
// также в make можно вторым параметром передавать размер

// с помощью использования литерала отображения(map):
m2 := map[int]int {
    // Пары ключ:значение указываются при необходимости
    12: 2,
    1:  5,
}

fmt.Println(m1) // map[]
fmt.Println(m2) // map[1:5 12:2]
```

### Основные взаимодействия

- Вставка:  

    ```
    m[key] = value
    ```
    
- Удаление:  

    ```
    delete(m, key)
    ```
- Поиск:  

    ```
    value = m[key] 
    ```  
    
    или  
    
    ```
    value, ok = m[key] 
    ```
 
#### Обход таблицы в go
  
```go
package main
import "fmt"

func main() {	
	m := map[int]bool{}	
	for i := 0; i < 5; i++ {		
		m[i] = ((i % 2) == 0)	
	}	
	for k, v := range m {		
		fmt.Printf("key: %d, value: %t\n", k, v)
	}
}
```

Вывод данной программы  будет разнится от запуска к запуску. ==А все потому, что мапа в Go unordered, то есть не упорядоченная. Это значит, что полагаться на порядок при обходе не надо.==

Причину можно найти в исходном коде рантайма языка:  
  
```go
// mapiterinit initializes the hiter struct used for ranging over maps.
func mapiterinit(t *maptype, h *hmap, it *hiter) {...
// decide where to start 
r := uintptr(fastrand()) 
... 
it.startBucket = r & bucketMask(h.B)...}
```

  ==Место поиска определяется **рандомно**, запомните это!==

### Поиск в таблице Go

 Стоит помнить, что ==когда мы пытаемся получить значение из мапы, а его там нет, получаем «нулевое значение типа», что в случае числа 0.== Что же делать, если мы хотим различать случаи 0 и отсутствия 2? Для этого придумали специальную форму «multiple assignment» — форма, когда вместо привычного одного значения мапа возвращает пару: само значение и еще одно булевое, отвечающее на вопрос, присутствует ли запрошенный ключ в мапе или нет".
 
Пример правильного поиска по таблице:

```go
package maini
mport (	"fmt")
func main() {	
	m := map[int]int{0: 0, 1: 10}	
	m2, ok := m[2]	
	if !ok {			
		m2 = 20	// что то делаем
	}	
	fmt.Println(m, m[0], m[1], m2)
}
```

### Как передается map в функцию?

==Содержимое таблицы передается по указателю(так что все ок), но сама переменная таблицы(указатель на нее) передается как копия, так что нельзя, например, объявить ее в одной функции, а иниализировать в другой==

```go
package main
func foo(m map[int]int) {     
	m[10] = 10 
}
func main() {	
	m := make(map[int]int)	
	m[10] = 15	
	println("m[10] before foo =", m[10]) //15
	foo(m)	
	println("m[10] after foo =", m[10]) //10
}
```

### Как устроена таблица

Мапа в Go — это просто указатель на структуру hmap. Это и является ответом на вопрос, почему при том, что мапа передается в функцию по значению, сами значения, лежащие в ней меняются — все дело в указателе. Так же структура hmap содержит в себе следующее: количество элементов, количество «ведер» (представлено в виде логарифма для ускорения вычислений), seed для рандомизации хэшей (чтобы было сложнее заddosить — попытаться подобрать ключи так, что будут сплошные коллизии), всякие служебные поля и главное указатель на buckets, где хранятся значения. Давайте посмотрим на рисунок:

![[Pasted image 20240621181255.png]]

На картинке схематичное изображение структуры в памяти — есть хэдер hmap, указатель на который и есть map в Go (именно он создается при объявлении с помощью var, но не инициализируется, из-за чего падает программа при попытке вставки). Поле buckets — хранилище пар ключ-значение, таких «ведер» несколько, в каждом лежит 8 пар. Сначала в «ведре» лежат слоты для дополнительных битов хэшей (e0..e7 названо e — потому что _extra_ hash bits). Далее лежат ключи и значения как сначала список всех ключей, потом список всех значений.  
  
По хэш функции определяется в какое «ведро» мы кладем значение, внутри каждого «ведра» может лежать до 8 коллизий, в конце каждого «ведра» есть указатель на дополнительное, если вдруг предыдущее переполнилось.

#### Как растет map?

В исходном коде можно найти строчку:  
  
```
 // Maximum average load of a bucket that triggers growth is 6.5.
```

то есть, если в каждом «ведре» в среднем более 6,5 элементов, происходит увеличение массива buckets. При этом выделяется массив в 2 раза больше, а старые данные копируются в него маленькими порциями каждые вставку или удаление, чтобы не создавать очень крупные задержки. Поэтому все операции будут чуть медленнее в процессе эвакуации данных (при поиске тоже, нам же приходится искать в двух местах). После успешной эвакуации начинают использоваться новые данные.

### Взятие адреса элемента map.

==Взятие адреса элемента map запрещено== из-за процессов "эвакуации" (указатель может стать недействительным)

### Заключение

Используйте мапы, но знайте и понимайте как они работают! Можно избежать граблей, поняв некоторые тонкости — почему нельзя взять адрес значения, почему все падает при объявлении без инициализации, почему лучше выделить память заранее, если известно количество элементов (избежим эвакуаций) и многое другое.

[Взято из](https://habr.com/ru/articles/457728/)
