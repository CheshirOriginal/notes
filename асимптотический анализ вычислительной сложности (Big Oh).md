Временную сложность наилучшего, наихудшего и среднего случаев для любого алго­ритма можно представить как числовую функцию от размеров возможных экземпляров задачи. Но работать с этими функциями очень трудно, поскольку они обладают сле­дующими свойствами: 

• являются слишком волнистыми. Время исполнения алгоритма, например, двоичного поиска, обычно меньше для массивов, имеющих размер n = i - 1, где k - целое число. Эта особенность не имеет большого значения, но служит предупреждением, что точная функция времен­ ной сложности любого алгоритма вполне может иметь неровный график с большим количеством небольших выпуклостей и впадин, как показано на рис.

![[xYraFKBS-yA.jpg]]

- требуют слишком много информации для точного определения. Чтобы подсчитать точное количество инструкций RАМ-машины, исполняемых в худшем случае, нужно, чтобы алгоритм был расписан в подробностях полной компьютерной программы. Более того, точность ответа зависит от маловажных де­талей кодировки (например, был ли употреблен в коде оператор `case` вместо вло­женных операторов `if`). Точный анализ наихудшего случая - например, такого: Т(n) = 12754n^2 + 4353n + 834lg2n + 13546 , очевидно, был бы очень трудной задачей, решение которой не предоставляет нам никакой дополнительной информации, кроме той, что «с увеличением п временная сложность возрастает квадратически».

Оказывается, намного легче работать с верхней и нижней границами функций времен­ ной сложности, используя для этого асимптотические («Big Oh») обозначения. Асим­птотические обозначения позволяют упростить анализ, поскольку игнорируют детали, которые не влияют на сравнение эффективности алгоритмов.

![[oGjMfuvOElk.jpg]]

![[LaOJvlb1QsQ.jpg]]

### Скорость роста

Используя асимптотические обозначения, мы пренебрегаем постоянными множителя­ми, не учитывая их при вычислении функций. При таком подходе функции f(n) 0,001n^2 и g(n) = 1000n^2 для нас одинаковы, несмотря на то, что значение функции g(n) в миллион раз больше значения функцииf(n) для любого n.  

Причина, по которой достаточно грубого анализа, предоставляемого обозначением О-большое, приводится в таблице, в которой приведены наиболее распространенные функции и их значения для нескольких значений n. В частности, здесь можно увидеть время исполнения f(n) операций алгоритмов на быстродействующем компьютере, вы­полняющем каждую операцию за одну наносекунду.

![[ozlXD4K_U-Q.jpg]]

==Из этого можно сделать основной вывод, что, даже игнорируя постоянные множители, мы получаем превосходное общее представление о годности алгоритма для решения задачи определенного размера.==

### Отношения доминирования

![[M3m3Y2tUDiA.jpg]]

- ==Функции-константы, f(n) = 1==. Такие функции могут измерять трудоемкость сложения двух чисел, распечатывания текста государственного гимна или рост таких функций, как f(n) = min(n, 100). По большому счету зависимость от параметра n отсутствует.
+ ==Логарифмические функции, f(n) = log n==. Логарифмическая временная сложность проявляется в таких алгоритмах, как дво­ичный поиск. С увеличением n эти функции возрастают довольно медленно, но бы­стрее, чем функции-константы (которые вообще не возрастают).
+ ==Линейные функции, f(n) = n.== Такие функции измеряют трудоемкость просмотра каждого элемента в массиве элементов один раз (или два раза, или десять раз)- например, для определения наибольшего или наименьшего элемента или для вычисления среднего значения.
+ ==Суперлинейные функции, f(n) = n lg n.== Этот важный класс функций возникает в таких алгоритмах, как quicksort и mergesort. Эти функции возрастают лишь немного быстрее, чем линейные, но достаточно быстро, чтобы подняться к более высокому классу доминирования.
+ ==Квадратичные функции,f(n) = n^2.== Эти функции измеряют трудоемкость просмотра большинства или всех пар элемен­тов в универсальном множестве из n элементов. Они возникают в таких алгоритмах, как сортировка вставками или сортировка методом выбора.  
+ ==Кубические функцuи, f(п) = n^3.== Эти функции перечисляют все триады элементов в универсальном множестве из п элементов. Они также возникают в определенных алгоритмах динамического про­граммирования.
+ ==Показательные функции, f(n) =с^n, константа с > 1.== Эти функции возникают при перечислении всех подмножеств множества из n эле­ментов. Экспоненциальные алгоритмы быстро становятся бесполезными с увеличением количества элементов n. Впрочем, не так быстро, как функции из следующего класса.  
+ ==Факториальные функции, f(n) = n!.== Факториальные функции определяют все перестановки п элементов.

![[ZaD5EuEZq0U.jpg]]

==ПОДВЕДЕНИЕ итогов==  
Хотя анализ алгоритмов высокого уровня может порождать экзотические функции, дkя большинства алгоритмов вполне достаточно лишь не­ большого ассортимента функций временной сложности (перечисленных ранее).

### Сложение функций

![[zQwuB1Ns_ss.jpg]]

### Умножение функций 

![[_fPHlQZZiNU.jpg]]

