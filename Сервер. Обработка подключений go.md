Для прослушивания и приемы входящих запросов в пакете net определена функция `net.Listen`:

```go
func Listen(network, laddr string) (net.Listener, error)
```

Функция принимает два параметра: network - протокол, по которому приложение будет получать запросы, и laddr представляет локальный адрес, по которому будет запускаться сервер. Протокол должен представлять одно из значений: "tcp", "tcp4", "tcp6", "unix", "unixpacket". Локальный адрес может содержать только номер порта, например, ":8080". В этом случае приложение будет обслуживать по всем.

В случае успешного выполнения функция возвращает объект интерфейса net.Listener, который представляет функционал для приема входящих подключений. В зависимости от типа используемого протокола возвращаемый объект Listener может представлять тип `net.TCPListener` или `net.UnixListener` (оба этих типа реализуют интерфейс `net.Listener`).

Основные методы, которые представляет net.Listener: `Accept()` (принимает входящее подключение) и `Close()` (закрывает подключение).

```go
package main
import (
    "fmt"
    "net"
)

func main() {
    message := "Hello, I am a server" // отправляемое сообщение
    
    listener, err := net.Listen("tcp", ":4545")
    if err != nil {
        fmt.Println(err)
        return
    }
    defer listener.Close()

    fmt.Println("Server is listening...")

    for {
        conn, err := listener.Accept()
        if err != nil {
            fmt.Println(err)
            return
        }
        
        conn.Write([]byte(message))
        conn.Close()
    }
}
```

Вначале в функции `net.Listen("tcp", ":4545")` устанавливается 4545 порт для прослушивания подключений по протоколу TCP. После вызова этой функции сервер запущен и готов принимать подключения. Затем в бесконечном цикле for получаем входящие подключения с помощью вызова `listener.Accept()`. Этот метод возвращает объект `net.Conn`, ==который представляет подключенного клиента==. Затем мы можем каким-нибудь образом обработать это подключение. Например, с помощью метода `Write` отправить ему сообщение. Поскольку данный метод принимает срез байтов, то любые сообщения надо транслировать в срез байтов: `conn.Write([]byte(message))`

Для тестирования сервера определим еще одну программу - клиент:

```go
package main

import (
    "fmt"
    "os"
    "net"
    "io"
)

func main() {
    conn, err := net.Dial("tcp", "127.0.0.1:4545")
    if err != nil {
        fmt.Println(err)
        return
    }
    defer conn.Close()
    
    io.Copy(os.Stdout, conn)
    fmt.Println("\nDone")
}
```

Запускаем сервер:

![[Pasted image 20240627160358.png]]

Затем запустим клиент:

![[Pasted image 20240627160419.png]]

После запуска клиент подключится к серверу и получит от него сообщение.

