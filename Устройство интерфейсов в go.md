```go
type iface struct {
    tab  *itab
    data unsafe.Pointer
}
```

Где `tab` — это указатель на `Interface Table` или `itable` — структуру, которая хранит некоторые метаданные о типе и список методов, используемых для удовлетворения интерфейса.  `data` — указывает на фактическую переменную с конкретным (статическим) типом. Наглядный пример:

```go
h := Human{Greeting: "Hello"} //структура
s := Speaker(h) //интерфейс
s.SayHello()
```

![[Pasted image 20240623153708.png]]

На рисунке видно, что **s** состоит из двух поинтеров, первый указывающий на itable для конкретной пары (статический тип Human, интерфейс Speaker), а другой на копию оригинального значения Human.

```go
h := Human{Greeting: "Hello"}
s := Speaker(h)
h.Greeting = "Meow"
s.SayHello() // выведет "hello"
```
### itable

Теперь несколько слов про itable. Поскольку эта таблица будет уникальна для каждой пары интерфейс-статический тип, то просчитывать её на этапе компиляции (early binding) будет нерационально и неэффективно.  
  
Вместо этого, компилятор генерирует метаданные для каждого статического типа, в которых, помимо прочего, хранится список методов, реализованных для данного типа. Аналогично генерируются метаданные со списком методов для каждого интерфейса. Теперь, во время исполнения программы, runtime Go может вычислить itable на лету (late binding) для каждой конкретной пары. Этот itable кешируется, поэтому просчёт происходит только один раз.  
  
Зная это, становится очевидно, почему Go ловит несоответствия типов на этапе компиляции, но кастинг к интерфейсу — во время исполнения. ==Не забывайте, что именно для того, чтобы безопасно ловить ошибки приведения к интерфейсным типам, существует конструкция comma-ok — `if s, ok := h.(Speaker); !ok { ... }`.==





