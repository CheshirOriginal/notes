При объявлении переменной мы можем присвоить ей значение в этот же момент. Это называется **инициализацией переменной**.

Язык C++ поддерживает 2 основных способа инициализации переменных.

**_Способ №1:_ Копирующая инициализация** (или _**«инициализация копированием»**_) с помощью знака равенства `=`:

```cpp
int nValue = 5; // копирующая инициализация|
```

**_Способ №2:_ Прямая инициализация** с помощью круглых скобок `()`:

```cpp
int nValue(5); // прямая инициализация
```

Прямая инициализация лучше работает с одними типами данных, копирующая инициализация — с другими.  

## uniform-инициализация

Прямая или копирующая инициализация работают не со всеми типами данных (например, вы не сможете использовать эти способы для инициализации списка значений).

В попытке обеспечить единый механизм инициализации, который будет работать со всеми типами данных, в C++11 добавили новый способ инициализации, который называется **uniform-инициализация**:

```cpp
int value{5};
```

Инициализация переменной с пустыми фигурными скобками указывает на инициализацию по умолчанию (переменной присваивается `0`):

```cpp
int value{}; // инициализация переменной по умолчанию значением 0 (ноль)
```

В uniform-инициализации есть еще одно дополнительное преимущество: вы не сможете присвоить переменной значение, которое не поддерживает её тип данных — компилятор выдаст предупреждение или сообщение об ошибке. Например:

```cpp
int value{4.5}; // ошибка: целочисленная переменная не может содержать нецелочисленные значения
```

==Правило: Используйте uniform-инициализацию==