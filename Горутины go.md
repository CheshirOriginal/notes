Горутины (goroutines) представляют параллельные операции, которые могут выполняться независимо от функции, в которой они запущены. Главная особенность горутин состоит в том, что они могут выполняться параллельно. То есть на многоядерных архитектурах есть возможность выполнять отдельные горутины на отдельных ядрах процессора, тем самым горутины будут выполняться параллельно, и программа завершится быстрее.

Каждая горутина, как правило, представляет вызов функции, и последовательно выполняет все свои инструкции. Когда мы запускаем программу на Go, мы уже работаем как минимум с одной горутиной, которая представлена функцией main. Эта функция последовательно выполняет все инструкции, которые определены внутри нее.

**Замечание**
> По умолчанию используется кол-во ядер вашего процессора. Но мы можем изменить количество используемых ядер простой строчкой кода. Приложению будет дана команда перейти на 4 ядра:
>
> `runtime.GOMAXPROCS(4)`

Для определения горутин применяется оператор go, который ставится перед вызовом функции:

```go
go вызов_функции
```

Например, определим несколько горутин, вычисляющих факториал числа:

```go
package main
import "fmt"

func main() {

    for i := 1; i < 7; i++ {
        go factorial(i)
    }
    fmt.Println("The End")
}

func factorial(n int){
    if n < 1 {
        fmt.Println("Invalid input number")
        return
    }
    result := 1
    for i := 1; i <= n; i++ {
        result *= i
    }
    fmt.Println(n, "-", result)

}
```

В цикле последовательно запускаются шесть горутин с помощью вызова `go factorial(i)`. То есть фактически это обычный вызов функции с оператором go. Однако вместо шести факториалов на консоли при вызове программы мы можем увидеть только строку "The End":

![[Pasted image 20240624131829.png]]

"Можем увидеть" означает, ==что поведение программы в данном случае недетерминировано==. Например, вывод может быть и таким:

![[Pasted image 20240624131857.png]]

Почему так происходит? После вызова `go factorial(i)` функция main запускает горутину, которая начинает выполняться в своем контексте, независимо от функции main. То есть фактически main и factorial выполняются параллельно. Однако главной горутиной является вызов функции main. И если завершается выполнение этой функции, то завершается и выполнение всей программы. Поскольку вызовы функции factorial представляют горутины, то функция main не ждет их завершения и после их запуска продолжает свое выполнение. Какие-то горутины могут завершиться раньше функции main, и соответственно мы сможем увидеть на консоли их результат. Но может сложиться ситуация, что функция main выполнится раньше вызовов функции factorial. Поэтому мы можем не увидеть на консоли факториалы чисел.

Горутины также могут представлять вызовы анонимных функций:

```go
package main
import "fmt"

func main() {
    for i := 1; i < 7; i++{
        go func (n int) {
            result := 1
            for j := 1; j <= n; j++ {
                result *= j
            }
            fmt.Println(n, "-", result)
        }(i)
    }
    fmt.Scanln() //не завершаем программу пока не введем что-либо
    fmt.Println("The End")

}
```