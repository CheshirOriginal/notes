Для упрощения синхронизации между горутинами в Go имеется пакет `sync`, который предоставляет ряд возможностей, в частности мьютексы. Мьютексы позволяют разграничить доступ к некоторым общим ресурсам, гарантируя, что только одна горутина имеет к ним доступ в определенный момент времени. И пока одна горутина не освободит общий ресурс, другая горутина не может с ним работать.

На уровне кода мьютекс представляет тип `sync.Mutex`. Для блокирования доступа к общему разделяемому ресурсу у мьютекса вызывается метод `Lock()`, а для разблокировки доступа - метод `Unlock()`.

Слово _мьютекс_ (**mutex**) является сокращением от _mutual exclusion_ (**взаимное исключение**). ==Горутины могут использовать мьютекс для исключения возможности делать что-то одновременно.==

В какой ситуации нам могут помочь мьютексы? Рассмотрим следующую ситуацию:

```go
package main
import "fmt"

var counter int = 0 //  общий ресурс
func main() {
    ch := make(chan bool) // канал
    for i := 1; i < 5; i++ {
        go work(i, ch)
    }
    // ожидаем завершения всех горутин
    for i := 1; i < 5; i++ {
        <-ch
    }
    fmt.Println("The End")
}

func work (number int, ch chan bool) {
    counter = 0
    for k := 1; k <= 5; k++ {
        counter++
        fmt.Println("Goroutine", number, "-", counter)
    }
    ch <- true
}
```

Функция work сбрасывает значение переменной counter к нулю и в цикле последовательно увеличивает ее значение до 5. В функции main запускается четыре горутин work. Но какой в данном случае будет консольный вывод? Он может быть, например, таким:

![[Pasted image 20240624173956.png]]

Несмотря на то, что в каждой горутине значение counter сбрасывается к 0, а затем увеличивается до 5, мы видим, что несколько горутин после сброса переменной работают совсем с другим значением. То есть при запуске горутин каждая из них получает значение переменной counter и начинает с ней работать. Пока одна горутина еще не закончила работу с counter в цикле, с этой же переменной начинает работать и другая горутина. То есть к одному и тому же разделяемому общему ресурсу - переменной counter одновременно работают сразу несколько горутин. Это может привести к некорректным результатам, как в данном случае.

С помощью мьютексов можно ограничить доступ к переменной таким образом, чтобы только одна горутина имела к ней монопольный доступ в один момент времени:

```go
package main
import (
"fmt"
"sync"
)

var counter int = 0 //  общий ресурс

func main() {
    ch := make(chan bool) // канал
    var mutex sync.Mutex // определяем мьютекс
    for i := 1; i < 5; i++ {
        go work(i, ch, &mutex)
    }

    for i := 1; i < 5; i++ {
        <-ch
    }
    fmt.Println("The End")
}

func work (number int, ch chan bool, mutex *sync.Mutex) {
    mutex.Lock() // блокируем доступ к переменной counter
    counter = 0
    for k := 1; k <= 5; k++ {
        counter++
        fmt.Println("Goroutine", number, "-", counter)
    }
    mutex.Unlock() // деблокируем доступ
    ch <- true
}
```

Теперь функция `work` принимает указатель на мьютекс. С помощью вызова `mutex.Lock()` мьютекс блокируется данной горутиной. ==Это значит, что к последующему коду имеет доступ только та горутина, которая первая заблокировала мьютекс. Остальные горутины ждут пока, мьютекс освободится.==

Далее горутина сбрасывает значение переменной `counter` к нулю и затем в цикле последовательно увеличивает его. В конце, когда все действия с общим ресурсом уже выполнены, горутина освобождает мьютекс с помощью вызова `mutex.Unlock()`. Ожидающие горутины получают сигнал, что мьютекс освободился, и одна из горутин блокирует мьютекс и начинает выполнять действия с переменной counter. И так далее горутины последовательно захватывают и освобождают мьютекс.

В итоге мы получим следующий результат:

![[Pasted image 20240624174832.png]]

### Хорошая практика по использованию mutex

> **На заметку:**
>  Это хорошая практика — держать определение мьютекса сразу над переменными, что он охраняет, и включать комментарий, чтобы связь между ними была ясна.

```go
// Пояснения к тому, посещались ли веб страницы
// Его методы могут использоваться конкурентно из нескольких горутин
type Visited struct {
    // mu охраняет карту с посещенными страницами
    mu      sync.Mutex // Объявление мьютекса
    visited map[string]int // Объявление карты из URL (строки) ключей к значениям integer
}
```

> **На заметку:** 
> В Go вы должны предполагать, что никакой метод не надежен для конкурентного использования, пока это явно не задокументировано, как мы делали выше.

Следующий код определяет метод `VisitLink`, что будет вызываться, когда встречается ссылка; он возвращает количество раз, когда ссылка встречалась ранее.

```go
// VisitLink отслеживает, сколько раз страницы с данным URL
// была посещена, и возвращает верное число

func (v *Visited) VisitLink(url string) int {
    v.mu.Lock() // Блокирует мьютекс
    defer v.mu.Unlock() // Убедитесь, что мьютекс разблокирован
    count := v.visited[url]
    count++
    v.visited[url] = count // Обновляет карту
    return count
}
```

Мьютекс неплох для прямого использования, ==он является важным инструментом при написании методов, что должны быть доступными для использования из нескольких горутин сразу.==
### Почему нужно быть осторожным с мьютексами в Golang?

В предыдущем примере, когда мьютекс заблокирован, мы делаем только одну простую вещь: мы обновляем карту. Чем больше действий будет произведено во время заблокированного состояния, тем осторожнее нужно быть. Если мы блокируем мьютекс для ожидания чего-то, когда мьютекс заблокирован, мы можем случайно заблокировать и другие элементы на долгое время. Еще хуже, если мы попытаемся заблокировать уже заблокированный мьютекс, это приведет к тупику — вызов `Lock` будет заблокирован навсегда.

Чтобы добиться безопасного состояния, придерживайтесь следующих правил:

- Старайтесь сделать код с мьютексом максимально простым и понятным с комментариями для подсказок;
- Не создавайте более одного мьютекса на данную часть разделенного состояния.

[[Долгодействующие задачи в Golang на примере]]



