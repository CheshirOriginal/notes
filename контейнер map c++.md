Начнём с контейнера [`std::map`](https://en.cppreference.com/w/cpp/container/map). Он определен в заголовочном файле `map`. Аналогично вектору, `std::map` является шаблонным: в угловых скобках нужно указать типы ключей и значений.

Рассмотрим пример:

```c++
#include <iostream>
#include <map>
#include <string>

int main() {
    // инициализируем map набором пар {ключ, значение}
    std::map<std::string, int> years = {
        {"Moscow", 1147},
        {"Rome", -753},
        {"London", 47},
    };

    for (const auto& [city, year] : years) {
        std::cout << city << ": " << year << "\n";
    }
}
// London: 47
// Moscow: 1147
// Rome: -753
```

При итерации с помощью `ranged-based for` возвращаются пары `std::pair` из константного ключа и значения. Для итерации по элементам мы использовали [structured binding](https://en.cppreference.com/w/cpp/language/structured_binding), прикрепив ссылки `city` и `year` к элементам возвращаемой пары, а также `auto` для автоматического вывода типа.

Контейнер `map` реализован как [красно-чёрное дерево](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree) — сбалансированное дерево поиска с особыми свойствами. Поэтому ==его элементы при итерации обходятся в порядке возрастания ключей==, а на самих ключах должен быть определён оператор `<` для сравнения.

![[Pasted image 20251007210059.png]]

Три основных операции в данной структуре данных — поиск, вставка и удаление элемента — выполняются за _логарифмическое время_ (O(log⁡n) от числа элементов в контейнере. Покажем, как воспользоваться этими операциями.

```c++
#include <iostream>
#include <map>
#include <string>

int main() {
    std::map<std::string, int> data;
    std::string key;
    int value;

    while (std::cin >> key >> value) {
        data[key] = value;  // вставка
    }

    data.erase("hello");  // удаление

    // поиск
    if (auto iter = data.find("test"); iter != data.end()) {
        std::cout << "Found the key " << iter->first << " with the value " << iter->second << "\n";
    } else {
        std::cout << "Not found\n";
    }
}
```

Рассмотрим эту программу подробнее.

Для вставки мы использовали обращение по ключу в квадратных скобках: `data[key] = value`. В отличие от вектора или дека, ключ теперь не обязательно является индексом: в нашем случае это строка. Альтернативные способы вставки — [`data.insert({key, value})`](https://en.cppreference.com/w/cpp/container/map/insert) или [`data.insert_or_assign(key, value)`](https://en.cppreference.com/w/cpp/container/map/insert_or_assign).

Эти функции принимают пару из ключа и значения, поэтому нам пришлось обрамить в фигурные скобки `key` и `value`, чтобы экземпляр `std::pair` сконструировался на лету. Если ключ `key` уже существует в контейнере, то `data[key] = value` и функция `insert_or_assign` его перезапишут, а `insert` — нет (но вернет информацию о старом значении).

Удаляя элемент по ключу, можно не заботиться о его наличии в контейнере: если ключа нет, то функция [`erase`](https://en.cppreference.com/w/cpp/container/map/erase) просто ничего не поменяет.

Для поиска элемента мы вызываем функцию [`find`](https://en.cppreference.com/w/cpp/container/map/find), которая возвращает итератор. Мы пользуемся [версией `if` с инициализатором](https://en.cppreference.com/w/cpp/language/if#If_Statements_with_Initializer), чтобы сразу сохранить этот итератор в переменную `iter` и потом проверить его значение. Итератор будет либо указывать на пару из найденного ключа и его значения, либо окажется равен значению `data.end()`, если ключ не найден. Обратиться к найденной паре можно через унарную звёздочку или стрелочку (`iter->first`). Это похоже на указатели, но важно понимать, что итератор ассоциативного контейнера — это не указатель, а самостоятельный объект.

Вернёмся ещё раз к конструкции `data[key]`. Она возвращает ссылку на значение, которому можно что-то присвоить. Сначала она проверяет, есть ли уже такой ключ в контейнере. Если ключа нет, он тут же вставляется в контейнер со значением по умолчанию (0 для `int`). Затем возвращается ссылка на значение в контейнере.

Такое поведение оператора `[]` требует, чтобы контейнер `data` был изменяемым. Поэтому выражение `data[key]` не скомпилируется, если `data` — константа:

```c++
void Check(const std::map<std::string, int>& data) {
    if (data["total"] > 0) {  // ошибка компиляции!
        // ...
    }
}
```

Если мы уверены, что ключ в контейнере есть, то можно воспользоваться функцией `at`:

```c++
void Check(const std::map<std::string, int>& data) {
    if (data.at("total") > 0) {  // OK, это скомпилируется
        // ...
    }
}
```

Если же ключа всё же не окажется, то `at` во время работы программы сгенерирует исключение которое можно перехватить и обработать.