Буферизированные каналы также создаются с помощью функции `make()`, только в качестве второго аргумента в функцию передается емкость канала. ==Если канал пуст, то получатель ждет, пока в канале появится хотя бы один элемент.==

==При отправке данных горутина-отправитель ожидает, пока в канале не освободится место для еще одного элемента и отправляет элемент, только тогда, когда в канале освобождается для него место.==

```go
package main
import "fmt"

func main() {
    intCh := make(chan int, 3)
    intCh <- 10
    intCh <- 3
    intCh <- 24
    fmt.Println(<-intCh) // 10
    fmt.Println(<-intCh) // 3
    fmt.Println(<-intCh) //24
}
```

В данном случае отправителем и получателем данных является функция main. В ней создается канал из трех элементов, и последовательно отправляются три значения типа int.

В то же время в данном случае должно быть соответствие между количеством отправляемых и получаемых данных. ==Если в функции main будет одновременно отправлено значений больше, чем вмещает канал, то функция заблокируется==:

```go
package main
import "fmt"

func main() {
    intCh := make(chan int, 3)
    intCh <- 10
    intCh <- 3
    intCh <- 24
    intCh <- 15 // блокировка - функция main ждет, когда освободится место в канале
    fmt.Println(<-intCh)
    fmt.Println("The End")
}
```

С помощью встроенных функций `cap()` и `len()` можно получить соответственно емкость и количество элементов в канале:

```go
package main
import "fmt"

func main() {
    intCh := make(chan int, 3)
    intCh <- 10
    fmt.Println(cap(intCh)) // 3
    fmt.Println(len(intCh)) // 1
    fmt.Println(<-intCh)
}
```
