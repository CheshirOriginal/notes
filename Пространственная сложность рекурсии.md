При расчете пространственной сложности рекурсивного алгоритма следует учитывать в основном две составляющие потребления пространства: пространство, связанное с рекурсией, и пространство, не связанное с рекурсией.

### Пространство, связанное с рекурсией

Пространство, связанное с рекурсией, относится к затратам памяти, которые непосредственно связаны с рекурсией, т. е. стеку для отслеживания рекурсивных вызовов функций. Для выполнения типичного вызова функции система выделяет в стеке некоторое пространство для хранения трех важных элементов информации:

- Адрес возврата вызова функции. После завершения вызова функции программа должна знать, куда возвращаться, т. е. строку кода после вызова функции.
- Параметры, передаваемые вызову функции.
- Локальные переменные внутри вызова функции.

Это пространство в стеке является минимальной стоимостью, которая несет вызов функции. Однако после завершения вызова функции это пространство освобождается.

В рекурсивных алгоритмах вызовы функций последовательно связываются в цепочку, пока не достигнут базового случая (также известного как нижний случай). Это означает, что пространство, используемое для каждого вызова функции, накапливается.

Для рекурсивного алгоритма, если нет других затрат памяти, то это пространство, занимаемое рекурсией, будет верхней границей пространства алгоритма.

==Для рекурсивного алгоритма, если нет другого потребления памяти, то это пространство, занимаемое рекурсией, будет верхней границей пространства алгоритма.==

Например, в упражнении printReverse у нас нет дополнительного использования памяти за пределами рекурсивного вызова, поскольку мы просто печатаем символ. Для каждого рекурсивного вызова предположим, что он может использовать пространство до постоянного значения. И рекурсивные вызовы будут связываться до n раз, где n — размер входной строки. Таким образом, пространственная сложность этого рекурсивного алгоритма равна O(n).

Чтобы проиллюстрировать это, для последовательности рекурсивных вызовов f(x1) -> f(x2) -> f(x3) мы показываем последовательность шагов выполнения вместе с расположением стека:

![[Pasted image 20251006164032.png]]

В стеке будет выделено место для f(x1), чтобы вызвать f(x2). Аналогично, в f(x2) система выделит еще одно место для вызова f(x3). Наконец, в f(x3) мы достигаем базового случая, поэтому в f(x3) больше нет рекурсивных вызовов.

==Именно из-за потребления пространства, связанного с рекурсией, иногда может возникнуть ситуация, называемая переполнением стека, когда стек, выделенный для программы, достигает своего максимального предела и программа вылетает. ==Поэтому при разработке рекурсивного алгоритма следует тщательно проверять, нет ли вероятности переполнения стека при увеличении объема входных данных.

### Пространство, не связанное с рекурсией

Как следует из названия, пространство, не связанное с рекурсией, относится к пространству памяти, которое не имеет прямого отношения к рекурсии и обычно включает в себя пространство (обычно в куче), выделенное для глобальных переменных.

Независимо от наличия рекурсии, вам может понадобиться сохранить входные данные задачи в виде глобальных переменных перед последующими вызовами функций. Кроме того, вам может понадобиться сохранить промежуточные результаты рекурсивных вызовов. Последнее также известно как мемоизация, как мы видели в предыдущих главах. Например, в рекурсивном алгоритме с мемоизацией для решения задачи о числах Фибоначчи мы использовали хэш-таблицу для отслеживания всех промежуточных чисел Фибоначчи, которые возникали во время рекурсивных вызовов. Поэтому при анализе пространственной сложности мы должны учитывать затраты пространства, связанные с мемоизацией.