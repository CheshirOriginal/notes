Многие новички в Go, особенно перешедшие с языков с динамической типизацией, видят в интерфейсных типах способ не работать с конкретными типами. "Заверну-ка я все в interface{}" — думает разработчик, и загрязняет свою программу интерфейсами, чаще всего пустыми.  
  
Но золотое правило тут звучит так — ==работайте всегда с конкретными типами, и используйте интерфейс только там где это необходимо, а пустой интерфейс — вообще в самых крайних случаях, когда иначе никак.==  
  
К примеру, пишете вы панель мониторинга, на которой выводите какие-то данные, и данные эти из одного источника приходят в виде float64 значений, а из другого в виде строк ("failed", "success" и т.п.). Как вы реализуете функцию, которая получает значения по каналу и выводит их на экран?
Большинство новичков скажут — легко, сделаем канал пустых интерфейсов (`chan interface{}`) и будем передавать по нему, а далее делать каст к типу:  
  
```go
func Display(ch chan interface{}) {
    for v := range ch {
        switch x := v.(type) {
        case float64:
            RenderFloat64(x)
        case string:
             RenderString(x)
        }
    }
}
```

И, хотя такой код тоже имеет право на существование, мы можем сделать это более красиво. Давайте подумаем, что общего в нашем случае у float64 и string? То что они оба должны быть отрендерены — это уже кандидат на создание интерфейса с методом Render. Попробуем:

```go
type Renderer interface {
    Render()
}
```
  
Далее, ==так как мы не можем навешивать методы на стандартные типы (это уже будет другой тип), то создадим свои MyFloat и MyString:==  
  
```go
type (
    MyFloat  float64
    MyString string
)
```

И реализуем методы Render для каждого, автоматически удовлетворяя интерфейсу Renderer:  

```go
func (f MyFloat) Render() { ... }
func (s MyString) Render() { ... }
```

И теперь наша функция `Display` будет иметь следующий вид:  

```go
func Display(ch chan Renderer) {
    for v := range ch {
        v.Render()
    }
}
```

Гораздо красивее и лаконично, не так ли? Теперь, если у нас добавится ещё один тип, который нужно уметь рендерить в Display — мы просто допишем ему метод Render и ничего больше менять не придется.  
  
==И, что важно, этот код отображает реальное положение вещей — объединяя типы под зонтом интерфейса по их общему поведению. Это поведение ортогонально самим данным, и теперь это отражено в коде.==

### Размеры интерфейсов

В [Go Proverbs](https://habrahabr.ru/post/272383/) есть такой постулат — ==_"Чем больше интерфейс, тем слабее абстракция"_.== В примере выше, маленький интерфейс всего с одним методом помог очень четко описать абстракцию "значения, которое нужно рендерить". Если бы мы создали интерфейс с кучей методов, специфичных для, скажем, string — мы не смогли бы его уже использовать для float64, и пришлось бы придумывать что-то новое.  
  
В Go большинство интерфейсов содержат 1-2 метода, не больше. Но это, конечно, не запрет — если вам совершенно точно нужен интерфейс с сотней методов (например, для моков каких-нибудь) — это тоже ок.
### Кто и когда должен создавать интерфейс?

У меня была интересная дискуссия, в ходе которой звучало следующее заявление — _"каждая библиотека в Go должна экспортировать интерфейс"_. Мол, если я захочу замокать (mock) функционал библиотеки, то мне достаточно будет просто реализовать этот интерфейс в своей заглушке и тестировать против него.  
  
Это не так. Каждая библиотека не должна экспортировать интерфейс, и общее правило для определения того, кто должен создавать интерфейс можно описать так:  
  
==**Интерфейс создается потребителем (consumer), а не продюсером (producer).**  ==
  
Если ваша библиотека реализует StaticType1, нет никакой нужны придумывать для неё интерфейс. Если же вы, как потребитель библиотеки, хотите абстрагировать поведение типа, замокать его и создать StaticType2, который в вашем коде должен быть взаимозаменяем со StaticType1 — вы у себя и имплементируйте Interface, и сами его и используйте. Это ваша задача — вы её и решаете средствами языка.  
В уже упомянутой выше библиотеке sort, интерфейс sort.Interface нужен для работы функции sort.Sort — то есть сама библиотека и является его потребителем.