Рассмотрим задачу вождения марсохода на поверхности Марса. Программное обеспечение для марсохода Curiosity структурировано как набор независимых модулей, которые общаются, передавая друг другу сообщения, что очень похоже на Go программы.

Модули марсохода отвечают за различные аспекты поведения машины. Попробуйте написать код Go, который управляет (очень упрощенным) марсоходом, движущимся на поверхности виртуального Марса. Поскольку у нас нет реального движка, мы справимся, обновив переменную, которая содержит координаты транспорта. Мы хотим, чтобы марсоход управлялся с Земли, поэтому он должен реагировать на внешние команды.

> **На заметку:** 
>Структуру кода, которую мы здесь создаем, можно использовать для любых долгоживущих задач, что действуют независимо, таких как веб сайт или аппаратный контроллер устройства.

Чтобы вести марсоход, мы запустим программу, которая будет отвечать за контроль его положения. Горутина запускается, когда запускается программное обеспечение марсохода, и остается до выключения. Поскольку он работает и оперирует независимо, мы назовем эту горутину `worker`, то есть рабочий.

`worker` пишется как цикл `for`, содержащий оператор `select`. Цикл повторяется пока рабочий `worker` жив. `select` ожидает чего-то интересного. В данном случае чем-то интересным может быть команда извне. Помните, хотя работник действует независимо, мы все же хотим иметь возможность контролировать его. Или это может быть событие таймера, сообщающее рабочему, что пора двигать марсоход.

Вот основа рабочей функции, которая ничего не делает:

```go
func worker() {
    for {
        select {
        // Ожидание каналов
        }
    }
}
```

Мы можем запустить такого работника точно так же, как мы **запускали горутины** в предыдущих примерах:

```go
go worker()
```

==Некоторые языки программирования используют **цикл обработки событий** — центральный цикл, который ожидает события и вызывает функции, когда они происходят. Предоставляя горутины в качестве основного концепта, Go устраняет необходимость в центральном цикле событий. Любая рабочая горутина может рассматриваться как отдельный **цикл обработки событий**.==

Мы хотим, чтобы марсоход периодически обновлял свою позицию. Для этого нужна рабочая горутина, которая заставляет его просыпаться, чтобы делать обновление. Для этого можно использовать `time.After`, который предоставляет канал, что получит значение после истечения определенного промежутка времени. Рабочий в следующем коде выводит значение каждую секунду. Пока вместо обновления позиции мы просто увеличиваем число. При получении **события таймера**, мы опять вызываем `After`, чтобы в следующий раз в цикле мы подождали новый канал таймера.

```go
func worker() {
    n := 0
    next := time.After(time.Second) // Создаем начальный канал таймера
    for {
        select {
        case <-next: // Ожидает истечение срока таймера
            n++
            fmt.Println(n) // Выводит число
            next = time.After(time.Second) // Создает другой канал таймера для другого события
        }
    }
}
```

Теперь, когда у нас есть работник, который может действовать сам по себе, давайте сделаем его более похожим на марсоход, обновив позицию а не просто число. Удобно, что в Go есть пакет `image`, что предоставляет тип `Point`, который мы можем использовать для представления текущего положения и направления движения марсохода. `Point` — это структура, содержащая координаты X и Y c соответствующими методами. Например, метод `Add` добавляет одну точку к другой.

Каждый раз, когда мы получаем значение на канале таймера, мы добавляем точку, представляющую текущее направление к текущей позиции, как показано в следующем коде. Прямо сейчас марсоход всегда будет начинать движение в одном и том же месте `[10, 10]` и продолжать движение на восток.

```go
func worker() {
    pos := image.Point{X: 10, Y: 10} // Текущая позиция (изначально [10, 10])
    direction := image.Point{X: 1, Y: 0} // Текущее направление (изначально [1, 0])
    next := time.After(time.Second)
    for {
        select {
        case <-next:
            pos = pos.Add(direction)
            fmt.Println("текущая позиция ", pos) // Выводит текущую позицию
            next = time.After(time.Second)
        }
    }
}
```

Не очень хорошо, если марсоход может двигаться только по прямой линии. Мы хотели бы иметь возможность управлять транспортом, чтобы заставить его двигаться в разных направлениях, или остановить его, или заставить его двигаться быстрее. Нам понадобится другой канал, который мы можем использовать для отправки команд работнику. Когда рабочий получает значение в командном канале, он сможет выполнить данную команду. ==В Go это обычно *скрытые за методами каналы*, потому что каналы считаются деталью имплементации.==

Тип `RoverDriver` в следующем коде содержит канал, который будет использоваться для отправки команд работнику. Мы будем использовать тип `command`, который будет содержать отправленные команды.

```go
// RoverDriver ведет марсоход по поверхности Марса.
type RoverDriver struct {
    commandc chan command
}
```

Мы можем задействовать логику, которая **создает канал** и запускает работника внутри функции `NewRoverDriver`, как показано в следующем коде. Мы собираемся определить метод `drive` для реализации рабочей логики. Хотя это метод, он будет функционировать так же, как функция `worker` из ранней части статьи. Как метод, он имеет доступ к любым значениям в структуре `RoverDriver`.

```go
func NewRoverDriver() *RoverDriver {
    r := &RoverDriver{
        commandc: make(chan command),
    }
    go r.drive()
    return r
}
```

Теперь нам нужно решить, какие команды отправить марсоходу. Чтобы упростить задачу, давайте задействуем только две команды: «повернуть на 90° влево» («turn 90° left») и «повернуть на 90° вправо» («turn 90° right»), как показано в следующем листинге.

```go
type command int
const (
    right = command(0)
    left  = command(1)
)
```

Теперь, когда мы определили тип `RoverDriver` и функцию для создания его экземпляра, нам нужен метод `drive` (рабочий, который будет управлять марсоходом), который приведен в следующем коде. Это почти то же самое, что работник для обновления позиции, которого мы видели ранее, за исключением того, что он тоже ждет на командном канале. Когда он получает команду, он решает, что сделать. Чтобы увидеть, что происходит, мы логируем изменения по мере их появления.

```go
// drive ответственен за вождение марсохода. Ожидается
// что он начнется в горутине.

func (r *RoverDriver) drive() {
    pos := image.Point{X: 0, Y: 0}
    direction := image.Point{X: 1, Y: 0}
    updateInterval := 250 * time.Millisecond
    nextMove := time.After(updateInterval)
    for {
        select {
        case c := <-r.commandc: // Ждет новых команд на командном канале
            switch c {
            case right: // поворот направо
               direction = image.Point{
                    X: -direction.Y,
                    Y: direction.X,
               }
            case left:  // поворот налево
               direction = image.Point{
                    X: direction.Y,
                    Y: -direction.X,
               }
            }
            log.Printf("new direction %v", direction)
        case <-nextMove:
            pos = pos.Add(direction)
            log.Printf("moved to %v", pos)
            nextMove = time.After(updateInterval)
        }
    }
}
```

Теперь мы можем завершить тип `RoverDriver`, добавив методы для управления марсоходом, как показано в следующем коде. Мы объявим два метода, по одному для каждой команды. Каждый метод отправляет правильную команду на канал `commandc`. Например, если мы вызываем метод `Left`, он отправит значение команды `left`, которое работник получит и изменит направление.

> **На заметку:** 
> Хотя эти методы контролируют направление движения марсохода, у них нет прямого доступа к значению направления, поэтому нет опасности, что они могут изменить его одновременно и рискнуть создать состояние гонки. Это означает, что нам не нужен **мьютекс**, потому что каналы позволяют поддерживать связь с горутиной марсохода без непосредственного изменения каких-либо его значений.

```go
// Left поворачивает марсоход налево (90° против часовой стрелки).
func (r *RoverDriver) Left() {
    r.commandc <- left
}
// Right поворачивает марсоход направо (90° по часовой стрелке).
func (r *RoverDriver) Right() {
    r.commandc <- right
}
```

Теперь, когда у нас есть полностью функциональный тип `RoverDriver`, следующий код создает марсоход и посылает ему несколько команд. Теперь можно свободно путешествовать по Марсу!

```go
func main() {
    r := NewRoverDriver()
    time.Sleep(3 * time.Second)
    r.Left()
    time.Sleep(3 * time.Second)
    r.Right()
    time.Sleep(3 * time.Second)
}
```

==Хотя мы сосредоточились на одном конкретном примере, этот рабочий паттерн может быть полезен во многих различных ситуациях, когда вам нужно иметь какую-то долгоживущую горутину, управляющую чем-то, оставаясь доступной для внешнего управления.==

