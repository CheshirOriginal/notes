Конвейер полезен для производства крупных потоков данных без использования больших объемов памяти. Хотя каждая горутина может содержать только одно значение за раз, со временем она может обработать множество значений. Конвейер очень полезен помогая решать многие проблемы более простыми способами.

Создадим объединение работников, что обрабатывают строки. Гофер в начале ряда объединения показан ниже — источник потока. Данный гофер не читает значения, он только отправляет их. В другой программе может задействоваться **чтение данных из файла**, базы данных или сети, но здесь мы просто отправим несколько произвольных значений. Чтобы сказать гоферам в нижнем потоке, что значений больше нет, источник закрывает канал.

```go
func sourceGopher(downstream chan string) {
	str := []string{"hello world", "a bad apple", "goodbye all"}
    for _, v := range str {
        downstream <- v
    }
    close(downstream)
}
```

Следующий гофер отфильтровывает все плохое из потока. Он читает элемент из верхнего канала и посылает его в канал нижнего потока только тога, когда в значении нет строки `"bad"`. 

```go
func filterGopher(upstream, downstream chan string) {
    for item := range upstream {
        if !strings.Contains(item, "bad") {
            downstream <- item
        }
    }
    close(downstream)
}
```

Гофер, что находится в конце конвейера — гофер вывода. У этого гофера нет ничего ниже него в потоке. В другой программе результаты можно было бы сохранить в файл или вывести в терминал итог рассмотренных значений. Здесь гофер-вывода показывает все увиденные значения.

```go
func printGopher(upstream chan string) {
    for v := range upstream {
        fmt.Println(v)
    }
}
```


Давайте объединим работников-гоферов вместе.

```go
func main() {
    c0 := make(chan string)
    c1 := make(chan string)
    go sourceGopher(c0)
    go filterGopher(c0, c1)
    printGopher(c1)
}
```



