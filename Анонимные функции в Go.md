[[Язык GoLang]]
### Функции как объекты первого класса

В Go функции являются объектами первого класса, это значит, что в этом языке программирования ==функцию можно передать в качестве аргумента другой функции или же вернуть функцию в качестве значения.==

Рассмотрим передачу функции в качестве аргумента другой функции на примере Map из уже знакомого нам пакета strings. Эта функция выглядит так:

```go
func Map(mapping func(rune) rune, s string) string
```

Функция Map в качестве первого аргумента получает функцию вида func (rune) rune, производящей какие-то действия с символом Unicode и возвращающей в качестве результата символ Unicode. Из описания этой функции следует, что переданная в качестве аргумента функция будет применена к каждому символу строки, переданной в качестве второго аргумента функции Map, получившаяся строка будет возвращена в качестве результата.

Создадим такую функцию:

```go
func invert(r rune) rune {
	// Если буква строчная, то она возвращается заглавной
	if unicode.IsLower(r) {
		return unicode.ToUpper(r)
	}
	// Иначе возвращается строчной
	return unicode.ToLower(r)
}
```

А теперь используем ее:

```go
func ExampleFirstClassFunctionArgument() {
	src := "aBcDeFg"
	test := "AbCdEfG"

	// Обратите внимание, что скобки после имени функции используются только при ее вызове
	src = strings.Map(invert, src)

	fmt.Printf("Инвертированная строка: %s. Результат: %v.\n", src, src == test)

	// Output:
	// Инвертированная строка: AbCdEfG. Результат: true.
}
```

Аналогично мы можем вернуть функцию в качестве значения:  

```go
func returnFunction() func(rune) rune {
	return invert
}
```

### Анонимная функция

Ранее, объявляя функцию, мы давали этой функции имя. Такое объявление можно сделать только за пределами других функций (на уровне пакета). Объявляя функцию на уровне пакета мы имеем возможность написать для такой функции необходимые тесты и удобно изменять ее реализацию. В этом нам в т.ч. помогает определенный уровень изоляции области видимости такой функции.

Однако в ряде случаев нам необходимо выполнить определенную задачу на месте, возможно предоставив функции доступ к области видимости вызывающей функции, как быть в этом случае? Язык Go позволяет нам использовать анонимные функции в любом выражении. ==Литерал такой функции записывается как объявление функции, но без имени после ключевого слова func.== Давайте немного изменим пример с функцией Map из пакета strings:

```go
func ExampleFunctionWithoutName() {
	src := "aBcDeFg"
	test := "AbCdEfG"

	// Обратите внимание, что скобки после имени функции используются только при ее вызове
	src = strings.Map(func(r rune) rune {
		if unicode.IsLower(r) {
			return unicode.ToUpper(r)
		}
		return unicode.ToLower(r)
	}, src)

	fmt.Printf("Инвертированная строка: %s. Результат: %v.\n", src, src == test)

	// Output:
	// Инвертированная строка: AbCdEfG. Результат: true.
}
```

==Анонимные функции могут быть объявлены в другой функции, присвоены переменной или вызваны на месте:==

```go
func ExampleUseNoNameFunction() {
	// Присваиваем переменной значение анонимной функции
	fn := func(a, b int) int { return a + b }

	// Выполняем анонимную функцию на месте
	// Обратите внимание на использование скобок при вызове функции
	func(a, b int) {
		fmt.Println(a + b)
	}(12, 34) // функция вызвана на месте 

	fmt.Println(fn(17, 15))

	// Output:
	// 46
	// 32
}
```

### Область видимости анонимной функции. Замыкание

В отличие от именованной функции, функция анонимная имеет доступ к окружению, в котором она была объявлена (в некоторых случаях объявление и вызов анонимной функции происходит одновременно):

```go
func externalFunction() func() {
	text := "TEXT"

	return func() {
		fmt.Println(text)
	}
}

func ExampleEnvironment() {
	fn := externalFunction()
	fn()

	// Output:
	// TEXT
}
```

Когда анонимная функция использует переменные, объявленные за ее рамками, ее называют замыканием. В приведенном примере мы объявили именованную функцию externalFunction, в которой объявляется переменная text. В качестве значения функция externalFunction возвращает замыкание - анонимную функцию, которая имеет доступ к переменной text, объявленной за ее пределами. Затем мы присвоили переменной fn результат выполнения функции externalFunction. Теперь fn - функция, мы вызываем ее, тем самым печатаем значение переменной text.

Усложним пример:

```go
func ExampleClosure() {
	fn := func() func(int) int {
		count := 0
		return func(i int) int {
			count++
			return count * i
		}
	}()

	for i := 1; i <= 5; i++ {
		fmt.Println(fn(i))
	}

	// Output:
	// 1
	// 4
	// 9
	// 16
	// 25
}
```

Здесь мы не просто печатаем значение переменной, но и изменяем его.

### Отложенный вызов анонимной функции

Мы уже говорили про defer в 2 модуле, напомним вам. Go позволяет отложить вызов внутренней функции до завершения функции внешней. Делается это с помощью ключевого слова defer перед вызовом функции. Отложенные функции выполняются в обратном порядке (LIFO):

```go
func ExampleDefer1() {
	defer func() { fmt.Println(1) }()

	defer func() { fmt.Println(2) }()

	defer func() { fmt.Println(3) }()

	// Output:
	// 3
	// 2
	// 1
}
```

С помощью отложенного вызова часто закрываются файлы и соединения, а также осуществляется обработка паники в работе функции, при этом используются возможности анонимных функций.

Как вы знаете, возбуждение аварии осуществляется вызовом функции panic(), которой в качестве аргумента передается любой требуемый объект. Восстановление же после аварии осуществляется вызовом функции recover(), возвращающей переданный функции panic() аргумент. При этом функция recover() может быть обработана, если ее вызов отложен до возникновения аварии:  
 

```go
func someFuncWithPanic() (err error) {
	defer func() {
		// отложенный вызов анонимной функции, проверяющей, что работа функции завершена
		// без ошибок. Если функция recover() возвращает что угодно кроме nil, значит в ходе
		// выполнения функции возникла паника.
		if e := recover(); e != nil {
			// Здесь происходит приведение интерфейса (об этом мы расскажем буквально в
			// следующем уроке. Результат приведения присваивается переменной err типа error
			// которая уже объявлена при самом вызове функции someFuncWithPanic.
			err = e.(error)

			// после этого анонимная функция завершает свою работу, паника обработана,
			// переменная err, в которой содержится информации о возникшей панике,
			// возвращается как результат выполнения функции.
		}
	}()

	panic(errors.New("fatal error"))
	return // или return nil ...
}

func ExamplePanicRecover() {
	if err := someFuncWithPanic(); err != nil {
		fmt.Println(err)
	}

	// Output:
	// fatal error
}
```