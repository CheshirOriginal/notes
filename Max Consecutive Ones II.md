
### Условие

Вам дан двоичный массив `nums`содержащую только нули и единицы. Вам нужно найти максимальное количество последовательных единиц, которое вы можете получить, если разрешено менять местами 0 и 1 не более одного раза.
### Пример

**Ввод:** [1,0,1,1,0]
**Выход:** 4
### Решение

```c++
// банальная идея: ищем масимальную подпоследовательность, состоящую из
// едениц и не более одного нуля с помощью скользящего окна (немного
// оптимизированного: так как мы ищим максимальную подпоследовательность
// нам нет смысла уменьшать окно, если в текущей последоваткльности 
// больше одного нуля, мы его просто сдвигаем вперед на шаг)
// либо можно и классическим скользящим окном
int findMaxConsecutiveOnes(std::vector<int>& nums) {  
    int l = 0, zc = 0;  
    for (int r = 0; r != nums.size(); ++r) {  
	    // если это 0, увеличиваем счетчик
        if (nums[r] == 0) {  
            ++zc;  
        }  
        // если нулей больше одного, то сдвигаем окно
        if (zc > 1) {  
            if (nums[l] == 0) {  
                --zc;  
            }  
            ++l;  
        }  
    }  
    // в конце получается наибольшее окно, размер которого это длина 
    // наибольшей последовательности
    return nums.size() - l;  
}
```