https://leetcode.com/problems/find-peak-element/description/
### Условие

Пиковый элемент — это элемент, который строго больше своих соседей.

Дан массив целых чисел **с индексом 0.**`nums` Найти пиковый элемент и вернуть его индекс. Если массив содержит несколько пиков, вернуть индекс **любого из них** .

Вы можете себе это представить `nums[-1] = nums[n] = -∞`. Другими словами, элемент всегда считается строго больше своего соседа, находящегося за пределами массива.

Вам необходимо написать алгоритм, который будет работать во `O(log n)`времени.

- `nums[i] != nums[i + 1]`для всех действительных `i`.
### Пример
**Ввод:** nums = [1,2,3,1]
**Выход:** 2

**Ввод:** nums = [1,2,1,3,5,6,4]
**Выход:** 5
### Решение

```go
// используется одна из версий бинарного поиска
// из условий nums[i] != nums[i + 1] и nums[-1] = nums[n] = -∞ следует,
// что пики всегда есть и массив чисел представляет из себя
// возрастающие и убывающие последовательности

func findPeakElement(nums []int) int {
    l, r := 0, len(nums) - 1
    for l < r {
        m := l + (r - l) / 2
        if nums[m+1] > nums[m] {
	        // если находимся на возрастающей последовательности
	        // то m не пик и пик лежит справа от m
            l = m + 1
        } else {
	        // если находимся на убывающей последовательности
	        // то либо m пик либо пик лежит слева от m
            r = m
        }
    }
    return l
}
// также держим в голове, что пиков может быть несколько
```