Существует множество способов, с помощью которых параллелизм делает нашу повседневную жизнь проще. Ниже приведены несколько концепций и методологий, с помощью которых мы можем сделать программы быстрее и надежнее.
### Генератор

Используя каналы, мы можем достаточно просто реализовать генератор. Так как вычисления в генераторе могут являться вычислительно дорогими, то мы могли бы сделать генерацию данных конкурентно. Таким образом, программе не нужно ждать, пока все данные будут сгенерированы. Например, генерация ряда Фибоначчи.

```go
package main
import "fmt"

// fib returns a channel which transports fibonacci numbersfunc
func fib(length int) <-chan int { 
	// make buffered channel    
	c := make(chan int, length)    
	
	// run generation concurrently    
	go func() {        
		for i, j := 0, 1; i < length; i, j = i+j, i {            
			c <- i        
		}        
		close(c)    
	}()    
	
	// return channel    
	return c
}

func main() {    
// read 10 fibonacci numbers from channel returned by `fib` function  
	for fn := range fib(10) {        
		fmt.Println("Current fibonacci number is", fn)    
	}
}
```

```
Current fibonacci number is 0
Current fibonacci number is 1
Current fibonacci number is 1
Current fibonacci number is 2
Current fibonacci number is 3
Current fibonacci number is 5
Current fibonacci number is 8
```

Используя функцию `fib`, мы получаем канал, который мы можем использовать в цикле. Находясь внутри функции `fib`, мы создаем и возвращаем канал только для приема. Возвращаемый канал преобразуется из двунаправленного канала в однонаправленный канал для приема. Используя анонимную горутину, мы помещаем числа Фибоначчи в этот канал. Как только мы закончили с циклом `for`, мы закрываем канал внутри анонимной горутины. В `main`, используя `range`, мы итерируем данные канала, полученные после вызова функции `fib`.

==Основной момент, который стоит понять, заключается в том, что функция `fib` возвращает канал практически мгновенно, а горутина, запущенная внутри этой функции, начинает генерировать и отправлять числа Фибоначчи в канал асинхронно.==

### Fan-in и Fan-out

Fan-in — это стратегия мультиплексирования, при которой входы нескольких каналов объединяются в один выходной канал. Fan-out — это обратная операция, при которой один канал разделяется на несколько каналов.

```go
package main
import (    
	"fmt"    
	"sync"
)

func getInputChan() <-chan int {    
   
	input := make(chan int, 100)    
 
	numbers := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}    
   
	go func() {        
		for num := range numbers {            
			input <- num        
		}               
		close(input)    
	}()    
	return input
}

getSquareChan(input <-chan int) <-chan int {    
	// make return channel    
	output := make(chan int, 100)    
	// run goroutine    
	go func() {        
		        
		for num := range input {  
			time.Sleep(time.Second * 3) // имитируем сложные вычисления
			output <- num * num        
		}        
		       
		close(output)    
	}()    
	return output
}

func merge(outputsChan ...<-chan int) <-chan int {    
 
	var wg sync.WaitGroup    

	merged := make(chan int, 100)  
	   
	wg.Add(len(outputsChan))
	      
	output := func(sc <-chan int) {             
		for sqr := range sc {            
			merged <- sqr        
		}              
		wg.Done()    
	}    
	
	for _, optChan := range outputsChan {        
		go output(optChan)    
	}
	
	go func() {  
		wg.Wait()        
		close(merged)    
	}()    
	
	return merged
}func 

main() {    
	chanInputNums := getInputChan()    
	
	chanOptSqr1 := getSquareChan(chanInputNums)    
	chanOptSqr2 := getSquareChan(chanInputNums)    
	
	chanMergedSqr := merge(chanOptSqr1, chanOptSqr2)    
	
	sqrSum := 0    
	
	for num := range chanMergedSqr {        
		sqrSum += num   
	}    
	
	fmt.Println("Sum of squares between 0-9 is", sqrSum)
}
```

Пройдем по шагам.
1. Получаем канал `chanInputNums`, посредством вызова функции `getInputChan`. Функция `getInputChan` создает канал и возвращает его как канал, доступный только для чтения, а также запускает анонимную горутину, которая последовательно помещает в канал числа из массива `numbers` и закрывает канал.
2. Разделяем наш канал (fan-out) на два канала(`chanOptSqr1` и `chanOptSqr2`), передавая его два раза функции `getSquareChan`. Функция `getSquareChan` создает канал и возвращает его как канал, доступный только для чтения, а также запускает анонимную горутину для вычисления квадрата чисел на основе данных канала, полученного в качестве аргумента функции.
3. Собираем данные из каналов в один (fan-in), используя функцию `merge`. В функции `merge` мы создаем `WaitGroup`, а также новый канал(`merged`), где мы объединим все данные из списка каналов `outputsChan`, после, мы увеличиваем счетчик на основании числа полученных каналов, подготавливаем анонимную функцию для чтения данных из канала и группировки данных в наш новый канал `merged`, а также уменьшим значение счетчика, когда все данные из переданного канала будут считаны. Вызываем нашу анонимную функцию для каждого канала в качестве горутины. А так же создаем и стартуем еще одну анонимную горутину для того, чтобы дождаться выполнения операции объединения всех данных в один канал и после этого закрываем канал в рамках анонимной функции. После чего возвращаем наш новый канал `merged`.
4. Считываем данные из канала `chanMergedSqr` используя `for` и `range`, и суммируем полученные данные.
5. В конце выводим наш результат.

==То есть мы параллелим вычисления с данными из входного потока на столько горутин, сколько раз вызывается функция getSquareChan, после чего соединяем результаты работы всех горутин в один канал.==
