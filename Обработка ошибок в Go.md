[[Язык GoLang]]

В отличие от других языков программирования, где разработчикам нужно обрабатывать ошибки с помощью специального синтаксиса (try catch/try except), ошибки в Go — это значения с типом `error`, возвращаемые функциями, как и любые другие значения. Для обработки ошибок в Go мы должны проверить ошибки, которые могут возвращать функции, решить, существует ли ошибка, а также принять надлежащие меры для защиты данных и сообщить пользователям или операторам, что произошла ошибка.

Самая простая обработка - это проверка ошибки на пустоту. Многие методы и функции в GO при вызове возвращают не только нужный результат, но и ошибку. К примеру: у нас есть функция которая делит число на другое число и ввод переменной.

```go
package main

import "fmt"

func divide(a int, b int) int {
	return a / b
}

func main() {
	var input int
	_, err := fmt.Scan(&input) // функция Scan возвращает два параметра, но нам сейчас важно проверить только ошибку
	if err != nil {
		fmt.Println("Проверьте типы входных параметров")
	} else {
		fmt.Println(divide(input, 5)) //Выведем результат, если ошибок нет
	}
}
```

`nil` - это пустота (`null` в других языках). Если переменная "err" не пустая - произошла ошибка, иначе - всё хорошо.

### Создание ошибок

Стандартная библиотека предоставляет две встроенные функции для создания ошибок: `errors.New` и `fmt.Errorf`. Обе эти функции позволяют нам указывать настраиваемое сообщение об ошибке, которое вы можете отображать вашим пользователям.

`errors.New` получает один аргумент — сообщение об ошибке в виде строки, которую вы можете настроить, чтобы предупредить ваших пользователей о том, что пошло не так.

```go
package main

import (
    "errors"
    "fmt"
)

func main() {
    err := errors.New("my error")
    fmt.Println("", err) // my error
}
```

### Оператор panic

Оператор **panic** позволяет сгенерировать ошибку и выйти из программы:

```go
package main
import "fmt"
 
func main() {
    fmt.Println(divide(15, 5))
    fmt.Println(divide(4, 0))
    fmt.Println("Program has been finished")
}
func divide(x, y float64) float64{
    if y == 0{ 
        panic("division by zero!")
    }
    return x / y
}
```

Оператору panic мы можем передать любое сообщение, которое будет выводиться на консоль. Например, в данном случае в функции divide, если второй параметр равен 0, то осуществляется вызов `panic("division by zero!")`.

В функции main в вызове `fmt.Println(divide(4, 0))` будет выполняться оператор panic, поскольку второй параметр функции divide равен 0. И в этом случае все последующие операции, которые идут после этого вызова, например, в данном случае это вызов `fmt.Println("Program has been finished")`, не будут выполняться. В этом случае мы получим следующий консольный вывод:

```
3
panic: division by zero!
```

И в конце вывода будет идти диагностическая информация о том, где возникла ошибка.

### Оператор defer

Оператор defer позволяет выполнить определенную операцию после каких-то действий (даже если сработает panic), при этом не важно, где в реальности вызывается эта функция. Например:

```go
package main
import "fmt"
 
func main() {
    defer finish()
    fmt.Println("Program has been started")
    fmt.Println("Program is working")
}
 
func finish(){
    fmt.Println("Program has been finished")
}
```

Здесь функция `finish` вызывается с оператором `defer`, поэтому данная функция в реальности будет вызываться в самом конце выполнения программы, несмотря на то, что ее вызов определен в начале функции main. В частности, мы получим следующий консольный вывод:

Program has been started
Program is working
Program has been finished

Если несколько функций вызываются с оператором defer, то те функции, которые вызываются раньше, будут выполняться позже всех. Например:

```go
package main
import  "fmt"
 
func main() {
      
    defer finish()
    defer fmt.Println("Program has been started")
    fmt.Println("Program is working")
}
 
func finish(){
    fmt.Println("Program has been finished")
}
```

Консольный вывод:

Program is working
Program has been started
Program has been finished

Дополнение: команда `defer` помещает вызов функции в стек. Поэтому они выполняются в очередности -LIFO (Last-In, First-Out)

`defer` запоминает значения переменных, переданных в функцию, на момент объявления defer, а не на момент его вызова. То есть условно

```go
a:=5

defer myFunc(a) // когда вызовется myFunc - будет передано значение 5, а не 7

a = 7
```
