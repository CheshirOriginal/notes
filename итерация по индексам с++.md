Так сложилось, что в стандартной библиотеке индексы и размеры контейнеров имеют беззнаковый тип. Вместо `unsigned int` или `unsigned long int` для него используется традиционный псевдоним [`size_t`](https://en.cppreference.com/w/cpp/types/size_t) (а точнее, `std::vector<T>::size_type`). Тип `size_t` на самом деле совпадает с `uint32_t` или `uint64_t` в зависимости от битности платформы. Его использование в программе дополнительно подчёркивает, что мы имеем дело с индексами или с размером.

Итерацию по элементам `data` с помощью индексов можно записать так:

```c++
for (size_t i = 0; i != data.size(); ++i) {
    std::cout << data[i] << " ";
}
```

==Это каноническая форма записи такого цикла==: в ней принято использовать сравнение `!=` и префиксный `++i`. Для целых чисел не будет разницы, если написать это как-то иначе (например, через `<` и постфиксный `i++`), но потом, когда вы будете писать аналогичные циклы для итераторов других контейнеров, разница появится. ==Давайте привыкнем всегда оформлять цикл по индексам так.==

Беззнаковость типа возвращаемого значения функции `size` порождает следующую проблему. По правилам, унаследованным ещё от языка C, результат арифметических действий над беззнаковым и знаковым типами приводится к беззнаковому типу. ==Поэтому выражение `data.size() - 1`, например, тоже будет беззнаковым. Если `data.size()` окажется нулём, то такое выражение будет вовсе не минус единицей, а самым большим беззнаковым целым== (для 64-битной платформы это 2^64 - 1).

Рассмотрим следующий ошибочный код, который проверяет, есть ли в векторе дубликаты, идущие подряд:

```c++
// итерация по всем элементам, кроме последнего:
for (size_t i = 0; i < data.size() - 1; ++i) {
    if (data[i] == data[i + 1]) {
        std::cout << "Duplicate value: " << data[i] << "\n";
    }
}
```

==Эта программа будет некорректно работать на пустом векторе.== Условие `i < data.size() - 1` на первой итерации окажется истинным, и произойдёт обращение к элементам пустого вектора. Правильнее было бы переписать это условие через ==`i + 1 < data.size()`== или воспользоваться внешней функцией [`std::ssize`](https://en.cppreference.com/w/cpp/iterator/size), которая появилась в C++20. Она возвращает знаковый размер вектора:

```c++
for (std::int64_t i = 0; i < std::ssize(data) - 1; ++i) {
    if (data[i] == data[i + 1]) {
        std::cout << "Duplicate value: " << data[i] << "\n";
    }
}
```