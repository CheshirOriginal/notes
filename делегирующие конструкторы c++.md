## Проблема

При создании нового объекта класса, компилятор C++ неявно вызывает конструктор этого объекта. Не редкость встретить класс с несколькими конструкторами, которые частично выполняют одно и то же, например:

```cpp
class Boo
{
public:
    Boo()
    {
        // Часть кода X
    }

    Boo(int value)
    {
        // Часть кода X
        // Часть кода Y
    }
};
```

Здесь есть 2 конструктора: конструктор по умолчанию и конструктор, который принимает целочисленное значение. Поскольку `Часть кода X` требуется обоим конструкторам, то она дублируется в каждом из них.

А как вы уже могли догадаться, дублирование кода — это то, чего следует избегать, поэтому давайте рассмотрим возможные решения этой проблемы.

## Делегирующие конструкторы в C++11

Начиная с C++11, конструкторам разрешено вызывать другие конструкторы. Этот процесс называется **делегированием конструкторов** (или _**«цепочкой конструкторов»**_). Чтобы один конструктор вызывал другой, нужно просто сделать вызов этого конструктора в списке инициализации членов. Например:

```cpp
class Boo
{
private:
public:
    Boo()
    {
        // Часть кода X
    }
    Boo(int value): Boo() // используем конструктор по умолчанию Boo() для выполнения части кода X
    {
        // Часть кода Y
    }
};
```

Всё работает как нужно. Убедитесь, что вы вызываете конструктор из списка инициализации членов, а не из тела конструктора.

Вот еще один пример использования делегирующих конструкторов для сокращения дублированного кода:

```cpp
#include <iostream>
#include <string>

class Employee
{
private:
    int m_id;
    std::string m_name;
    
public:
    Employee(int id=0, const std::string &name=""):
        m_id(id), m_name(name)
    {
        std::cout << "Employee " << m_name << " created.\n";
    }
    // Используем делегирующие конструкторы для сокращения дублированного кода
    Employee(const std::string &name) : Employee(0, name) { }

};

int main()
{
    Employee a;
    Employee b("Ivan");
    return 0;
}
```

Этот класс имеет 2 конструктора (один из которых вызывает другой). Таким образом, количество дублированного кода сокращено (нам нужно записать только одно определение конструктора вместо двух).

## Несколько заметок о делегирующих конструкторах

Во-первых, конструктору, который вызывает другой конструктор, не разрешается выполнять какую-либо инициализацию членов класса. Поэтому конструкторы могут либо вызывать другие конструкторы, либо выполнять инициализацию, но не всё сразу.

Во-вторых, один конструктор может вызывать другой конструктор, в коде которого может находиться вызов первого конструктора. Это создаст бесконечный цикл и приведет к тому, что память стека закончится и произойдет сбой. Вы можете избежать этого, убедившись, что в конструкторе, который вызывается, нет вызова первого (и вообще любого другого) конструктора. Будьте аккуратны и не используйте вложенные вызовы конструкторов.