Срезы можно рассматривать как расширенную реализацию массивов.  
Срезы были реализованы в Go, чтобы покрыть некоторые крайне распространенные варианты использования, с которыми разработчики сталкиваются при работе с коллекциями, например, динамическое изменение размера коллекций.  
  
Объявление среза очень похоже на объявление массива, за исключением того, что опускается спецификатор длины:  
  
```go
slice := []int{4, 5, 3}
```

Если просто смотреть на код, то кажется, что срезы и массивы достаточно похожи, но основное их отличие лежит в реализации и условиях использования.
### Представление в памяти

Срез аллоцируется иначе, чем массив, и по сути является модифицированным указателем. Каждый срез содержит в себе три блока информации:
1. Указатель на последовательность данных.
2. Длину (length), которая определяет количество элементов, которые сейчас содержатся в срезе.
3. Объем (capacity), который определяет общее количество предоставленных ячеек памяти.

![[Pasted image 20240619181639.png]]

Из этого следует, что срезы разной длины можно присваивать друг другу. Они имеют один и тот же тип, а указатель, длина и объем могут меняться:  
  
```go
slice1 := []int{6, 1, 2}
slice2 := []int{9, 3}

// slices of any length can be assigned to other slice types
slice1 = slice2
```

Срез, в отличии от массива, не выделяет память во время инициализации. Фактически, срезы инициализируется с нулевым (`nil`) значением.
### Передача по ссылке

Когда вы присваиваете срез другой переменной, вы все еще передаете значение. Здесь значение обращается только к указателю, длине и объему, а не к памяти, занимаемой самими элементами.

![[Pasted image 20240619181938.png]]

### Добавление новых элементов

Чтобы добавить новые элементы к срезу, необходимо использовать функцию `append`.  
  
```go
nums := []int{8, 0}
nums = append(nums, 8)
```

Под капотом это будет выглядеть, как присвоение значения, указанного для нового элемента, и после – возвращение нового среза. Длина нового среза будет на единицу больше. Если новая длинна превышает capacity, то оно увеличивается в 2 раза (как минимум обычно)

![[Pasted image 20240619182925.png]]

Именно поэтому чаще всего рекомендуется создавать срез с длиной и объемом, указанными заранее (особенно, если вы четко имеете представление какого размера срез вам нужен): 
  
```go
arr := make([]int, 0, 5)
// This creates a slice with length 0 and capacity 5
```

### Основные функции
- `cap` - возвращает capacity
- `len` - возвращает length
- `copy` - копирует элементы одного среза в другой, возвращает кол-во скопированных элементов
- и т.д.
### Оператор среза

Оператор среза `s[i:j]` создает из последовательности s новый срез, который содержит элементы последовательности s с i по j-1. При этом должно соблюдаться условие 0 <= i <= j <= cap(s). В качестве исходной последовательности, из которой берутся элементы, может использоваться массив, указатель на массив или другой срез. В итоге в полученном срезе будет j-i элементов.

Если значение i не указано, то применяется по умолчанию значение 0. Если значение j не указано, то вместо него используется длина исходной последовательности s.

```go
initialUsers := [8]string{"Bob", "Alice", "Kate", "Sam", "Tom", "Paul", "Mike", "Robert"} // базовый массив

users1 := initialUsers[2:6] // с 3-го по 6-й
users2 := initialUsers[:4] // с 1-го по 4-й
users3 := initialUsers[3:] // с 4-го до конца

fmt.Println(users1) // [Kate Sam Tom Paul]
fmt.Println(users2) // [Bob Alice Kate Sam]
fmt.Println(users3) // [Sam Tom Paul Mike Robert]
```

### Использование append для удаления элемента из среза

В Go отсутствует встроенная функция для удаления элемента из среза, но мы можем воспользоваться функцией append для того, чтобы создать новый срез, включающий в себя срез элементов до игнорируемого элемента, а также все элементы после игнорируемого:

```go
a := []int{1, 2, 3, 4, 5, 6, 7}
a = append(a[0:2], a[3:]...)
fmt.Println(a) // [1 2 4 5 6 7]
```

### Функция copy - копирование элементов среза

Copy принимает срез-назначение и срез источник, а возвращает число скопированных элементов:

```go
a := []int{1, 2, 3}
b := make([]int, 3, 3)
n := copy(b, a)

fmt.Printf("a = %v\n", a)                  // a = [1 2 3]
fmt.Printf("b = %v\n", b)                  // b = [1 2 3]
fmt.Printf("Скопировано %d элемента\n", n) // Скопировано 3 элемента
```

Почему мы явно указали длину создаваемого среза b? Потому что иначе функции было бы некуда копировать. Имей срез b длину 1, был бы скопирован 1 элемент из среза a.

### Небольшое дополнение по использованию многоточия (...)

язык Go предусматривает обратный способ использования многоточия - разворачивание (раскрытие) среза путем указания _справа_ от среза знака многоточия. Пример

```go
func ExampleExpandSlice2() {
	s1 := []int{1, 2, 3, 4, 5}
	s2 := []int{6, 7, 8, 9, 10}

	// append(slice []Type, elems ...Type) []Type

	// s1 = append(s1, s2) не сработает, т.к. второй и
	// последующие аргументы в нашем случае должны быть int

	s1 = append(s1, s2...)
	fmt.Println(s1)

	// Output:
	// [1 2 3 4 5 6 7 8 9 10]
}
```


