Итак, начнем с первого важного момента, который достаточно легок в понимании — **интерфейсы определяют поведение**. В этом плане, интерфейс в Go практически не отличается от интерфейсов в Java. К примеру, вот интерфейс и его реализация в Java:  

```java
public interface Speakable {    
	public String greeting = "Hello";    
	public void sayHello();
}

public class Human implements Speakable {    
	public void sayHello() {        
		System.out.println(Speakable.greeting);    
	}
}

Speakable speaker = new Human();
speaker.sayHello();
```
  
Пример на Go:  

```go
type Speaker interface {
    SayHello()
}

type Human struct {
    Greeting string
}

func (h Human) SayHello() {
    fmt.Println(h.Greeting)
}
...
var s Speaker
s = Human{Greeting: "Hello"}
s.SayHello()
```

На первый взгляд, отличия чисто косметические:

- в Java используются ключевые слова public/protected/etc, в Go — case первой буквы имени методы определяет видимость
- в Java чаще называют интерфейсы с постфиксом -able, в Go же принято использовать постфикс -er (Sender, Reader, Closer, etc)
- в Java используются классы для имплементации интерфейса, в Go — структуры с методами.
- в Java имплементация интерфейса указывается явно(_implements_), в Go — неявно(duck typing)
- в Java и интерфейсы, и классы могут содержать и данные, и методы, в Go — интерфейс не может содержать данные, только методы.

Но некоторые из этих отличий оказываются ключевыми, в частности последние два из них. Остановимся на них детальнее:

### Неявная имплементация

> Если это выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, утка и есть.
  
В Go структура с методами будет удовлетворять интерфейсу просто самим фактом объявления метода. Это кажется не особо важным на маленьких программах или искусственных примерах, но **оказывается ключевым в больших проектах**, где приходится думать дважды перед тем как изменить какой-то класс, многократно унаследованный другими классами.  
  
Возможность легко и просто неявно реализовать различные интерфейсы позволяет программам безболезненно расти, без необходимости продумывать все возможные интерфейсы наперёд и не утопать во множественном наследовании. Это к слову о том, что Go задумывался для облегчения жизни в больших проектах.  
  
Важное и не сразу очевидное различие этого заключается в том, как, в итоге, вы строите архитектуру вашей программы — в Java или C++ вы, скорее всего, начинаете с объявления абстрактных классов и интерфейсов, и далее переходите к конкретным реализациям. ==В Go же наоборот — вы пишете сначала конкретный тип, определяете данные и методы, **и только в том случае, если действительно появляется необходимость абстрагировать поведение** — создаете отдельный интерфейс==. Опять же, масштаб этого различия более ощутим на больших проектах.
### Данные vs поведение

Если в Java и классы, и интерфейсы описывают как данные, так и поведение, то в Go эти понятия кардинально разграничены. **Структура хранит данные, но не поведение. Интерфейс хранит поведение, но не данные.**  
  
Если вам хочется добавить в интерфейс переменную вроде `Hello string` — знайте, вы что-то делаете не так. Если вы хотите встроить интерфейс в структуру — вы путаете поведение и данные. В мире Java это нормально, но в Go это важное разделение, поскольку формирует ясность абстракций.  
  
В примере выше, Speaker описывает поведение, но никак не говорит, что именно должен говорить тот, кто реализует этот интерфейс. Опять же, Speaker как **интерфейс в Go коде появился из практической необходимости быть реализованным каким-то другим типом**, а не как "базовый класс", к которому написали конкретную реализацию Human.  
  
Важно понимать, что как только вы начнёте четко разделять абстракции "поведения" и "данных" — вы начнёте более четко понимать назначение и правильный способ использования интерфейсов в Go. **Human и Speaker — ортогональны**. Human может с легкостью удовлетворять ещё 10-ти интерфейсам (Walker, Listener, Player, Programmer, etc), а Speaker может быть удовлетворён десятками типов, даже из других пакаджей (Robot, Animal, Computer, etc). И всё это, с минимальными накладными синтаксическими расходами, что, опять же, важно в больших кодовых базах.



