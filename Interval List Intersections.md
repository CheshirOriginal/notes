https://leetcode.com/problems/interval-list-intersections/description/
### Условие

Вам даны два списка замкнутых интервалов, firstList и secondList, где firstList[i] = [starti, endi] и secondList[j] = [startj, endj]. Каждый список интервалов является попарно дизъюнктным и отсортированным.

Верните пересечение этих двух списков интервалов.

Замкнутым интервал [a, b] (где a <= b) обозначает множество действительных чисел x, для которых a <= x <= b.

Пересечение двух замкнутых интервалов — это множество действительных чисел, которое либо пустое, либо представлено в виде закрытого интервала. Например, пересечение [1, 3] и [2, 4] — это [2, 3].
### Пример
**Ввод:** firstList = \[[0,2],[5,10],[13,23],[24,25]], secondList = \[[1,5],[8,12],[15,24],[25,26]]
**Выход:** \[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]

![[Pasted image 20250918221446.png]]

**Ввод:** firstList = \[[1,3],[5,9]], secondList = []
**Выход:** []
### Решение
```go
func intervalIntersection(firstList [][]int, secondList [][]int) [][]int {  
    res := [][]int{}  
    p1, p2, l, r := 0, 0, 0, 0  
  
    for p1 < len(firstList) && p2 < len(secondList) {  
	    // определяем наибольшее начало среди интервалов
       if firstList[p1][0] >= secondList[p2][0] {  
          l = firstList[p1][0]  
       } else {  
          l = secondList[p2][0]  
       }  
	  // определяем наименьший конец среди интервалов
       if firstList[p1][1] <= secondList[p2][1] {  
          r = firstList[p1][1]  
       } else {  
          r = secondList[p2][1]  
       }  
	  // если начало меньше конца, то это пересечение
       if l <= r {  
          res = append(res, []int{l, r})  
       }  
	  // сдвигаем один из указателей
	  // итервал с меньшим концом  нам больше неинтересен, поэтому
	  // сдвигаем именно его
       if firstList[p1][1] >= secondList[p2][1] {  
          p2++  
       } else {  
          p1++  
       }  
    }  
    return res  
}
```