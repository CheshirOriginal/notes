До этого момента мы записывали определения всех наших виртуальных функций. Однако C++ позволяет создавать особый вид виртуальных функций, так называемых **чистых виртуальных функций** (или **_«абстрактных функций»_**), которые вообще не имеют определения! Переопределяют их дочерние классы.

При создании чистой виртуальной функции, вместо определения (написания тела) виртуальной функции, мы просто присваиваем ей значение `0`.

```cpp
class Parent
{
public:
    const char* sayHi() { return "Hi"; } // обычная невиртуальная функция    
    virtual const char* getName() { return "Parent"; } // обычная виртуальная функция
    virtual int getValue() = 0; // чистая виртуальная функция
    int doSomething() = 0; // ошибка компиляции: нельзя присвоить невиртуальным функциям значение 0
};
```

Таким образом, мы сообщаем компилятору: «Реализацией этой функции займутся дочерние классы».

Использование чистой виртуальной функции имеет два основных последствия:

- Во-первых, любой класс с одной и более чистыми виртуальными функциями становится **абстрактным классом**, объекты которого создавать нельзя!

- Во-вторых, все дочерние классы абстрактного родительского класса должны переопределять все чистые виртуальные функции, в противном случае — они также будут считаться абстрактными классами.
## Чистые виртуальные функции с определениями

Оказывается, мы можем определить чистые виртуальные функции:

```cpp
#include <iostream>
#include <string>

class Animal // это абстрактный родительский класс
{
protected:
    std::string m_name;
public:
    Animal(std::string name)
        : m_name(name)
    {

    }
    
    std::string getName() { return m_name; }
    virtual const char* speak() = 0; // присваивание значения "= 0" говорит о том, что эта функция является чистой виртуальной функцией
};

const char* Animal::speak()  // несмотря на то, что вот здесь находится её определение
{
    return "buzz";
}
```

В этом случае speak() по-прежнему считается чистой виртуальной функцией (хотя позже мы её определили), а Animal по-прежнему считается абстрактным родительским классом (и, следовательно, объекты этого класса не могут быть созданы). Любой класс, который наследует класс Animal, должен переопределить метод speak() или он также будет считаться абстрактным классом.

При определении чистой виртуальной функции, её тело (определение) должно быть записано отдельно (не встроено).

Это полезно, когда вы хотите, чтобы дочерние классы имели возможность переопределять виртуальную функцию или оставить её реализацию по умолчанию (которую предоставляет родительский класс). В случае, если дочерний класс доволен реализацией по умолчанию, он может просто вызвать её напрямую. Например:

```cpp
#include <iostream>
#include <string>

class Animal // это абстрактный родительский класс
{
protected:
    std::string m_name;
public:
    Animal(std::string name)
        : m_name(name)
    {

    }

    std::string getName() { return m_name; }
    virtual const char* speak() = 0; // обратите внимание, speak() является чистой виртуальной функцией
};

const char* Animal::speak()
{
    return "buzz"; // реализация по умолчанию
}

class Dragonfly: public Animal
{
public:
    Dragonfly(std::string name)
        : Animal(name)
    {
    }
    
    virtual const char* speak() // этот класс уже не является абстрактным, так как мы переопределили функцию speak()
    {
        return Animal::speak(); // используется реализация по умолчанию класса Animal
    }
};

int main()
{
    Dragonfly dfly("Barbara");
    std::cout << dfly.getName() << " says " << dfly.speak() << '\n';
}
```

Результат выполнения программы:

```
Barbara says buzz
```
## Интерфейсы

**Интерфейс** — это класс, который не имеет переменных-членов и все методы которого являются чистыми виртуальными функциями! Интерфейсы еще называют **_«классами-интерфейсами»_** или **_«интерфейсными классами»_**.

Интерфейсные классы принято называть с `I` в начале, например:

```cpp
class IErrorLog
{
public:
    virtual bool openLog(const char *filename) = 0;
    virtual bool closeLog() = 0;
    virtual bool writeError(const char *errorMessage) = 0;
    virtual ~IErrorLog() {}; // создаем виртуальный деструктор, чтобы вызывался соответствующий деструктор дочернего класса в случае, если удалим указатель на IErrorLog
};
```

Любой класс, который наследует IErrorLog, должен предоставить свою реализацию всех 3 методов класса IErrorLog. Вы можете создать дочерний класс с именем FileErrorLog, где openLog() открывает файл на диске, closeLog() — закрывает файл, а writeError() — записывает сообщение в файл. Вы можете создать еще один дочерний класс с именем ScreenErrorLog, где openLog() и closeLog() ничего не делают, а writeError() выводит сообщение во всплывающем окне.

Теперь предположим, что вам нужно написать программу, которая использует журнал ошибок. Если вы будете писать классы FileErrorLog или ScreenErrorLog напрямую, то это неэффективно. Например, следующая функция заставляет все объекты, вызывающие mySqrt(), использовать FileErrorLog, что может быть не всегда уместно:

```cpp
#include <cmath> // для sqrt()
double mySqrt(double value, FileErrorLog &log)
{
    if (value < 0.0)
    {
        log.writeError("Tried to take square root of value less than 0");
        return 0.0;
    }
    else
        return sqrt(value);
}
```

Намного лучшим вариантом будет реализация через IErrorLog:

```cpp
#include <cmath> // для sqrt()

double mySqrt(double value, IErrorLog &log)
{
    if (value < 0.0)
    {
        log.writeError("Tried to take square root of value less than 0");
        return 0.0;
    }
    else
        return sqrt(value);
}
```

Теперь пользователь через передачу объектов может определить самостоятельно, какой класс следует вызывать. Если он хочет, чтобы ошибка была записана в файле, то он передаст в функцию mySqrt() объект класса FileErrorLog. Если он хочет, чтобы ошибка выводилась на экран, то он передаст объект класса ScreenErrorLog. Или, если он хочет сделать то, что вы не предусмотрели, например, отправить кому-то Email-ом сообщение ошибки, то он может создать новый дочерний класс EmailErrorLog, который будет наследовать IErrorLog, и передавать объект этого класса! Таким образом, реализация через IErrorLog делает нашу функцию более гибкой и независимой.

==Не забудьте о подключении виртуальных деструкторов в ваши интерфейсные классы, чтобы при удалении указателя на интерфейс вызывался деструктор соответствующего (дочернего) класса.==

Интерфейсы чрезвычайно популярны, так как они просты в использовании, удобны в поддержке, и их функционал легко расширять. Некоторые языки, такие как Java и C#, даже добавили в свой синтаксис **ключевое слово interface**, которое позволяет программистам напрямую определять интерфейсный класс, не указывая явно, что все методы являются абстрактными.

