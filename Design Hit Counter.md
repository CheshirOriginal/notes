
### Условие

Необходимо реализовать класс `HitCounter`, который считает количество «хитов» (событий) за последние **5 минут** (300 секунд).

Методы класса:
- `HitCounter()` — конструктор, инициализирует систему.
- `void hit(int timestamp)` — регистрирует хит в момент `timestamp` (в секундах). Может быть несколько хитов с одинаковым временем.
- `int getHits(int timestamp)` — возвращает количество хитов, случившихся за последние 5 минут от `timestamp`, то есть в интервале **[timestamp − 299, timestamp]** (включительно).

**Дополнительные условия / уточнения:**

- Входные вызовы происходят **в хронологическом порядке**, то есть переданные `timestamp` не убывают.
- `timestamp` выражен в секундах.
- Может быть несколько вызовов `hit` с одним и тем же `timestamp`. 
- Нужно, чтобы методы работали эффективно. В частности, при большом числе хитов в секунду важно, чтобы решение масштабировалось. (То есть не хранить все хиты бесконечно)
### Пример

```java
HitCounter counter = new HitCounter();

counter.hit(1);
counter.hit(2);
counter.hit(3);
counter.getHits(4);    // → 3   (хиты в интервале [4−299, 4] = [−295,4] — это 1,2,3)
counter.hit(300);
counter.getHits(300);  // → 4   (все хиты: 1,2,3,300)
counter.getHits(301);  // → 3   (интервал [301−299,301] = [2,301], хиты 2,3,300)
```
### Решение

```cpp
class HitCounter {  
private:  
    int total_hits = 0;  
    std::queue<std::pair<int, int>> hits_freq;  
  
public:  
    HitCounter() {}  
  
    void hit(int timestamp) {  
	    // если очередь не пуста и в ней уже есть запись с этой
	    // временной меткой, то увеличиваем счетчик
	    if(!hits_freq.empty() && hits_freq.back().first == timestamp) {
	        hits_freq.back().second++;  
	    // иначе добавляем новую запись
	    } else {  
	        hits_freq.emplace(timestamp,1);  
	    }  
	    // не забываем обновить счетчик
	    total_hits++;  
	}
  
    int getHits(const int timestamp) {  
	    // пока очередь не пуста и временная метка записи из начала 
	    // очереди более чем на 300 старше переданной метки
        while(!hits_freq.empty() && (timestamp - hits_freq.front().first) >= 300){  
		    // уменьшаем счетчик
            total_hits -= hits_freq.front().second;  
            // удаляем элемент
            hits_freq.pop();  
        }  
        // возвращаем актуальный счетчик записей старших не более
        // чем на 300 секунд переданной метки
        return total_hits;  
    }  
};
```