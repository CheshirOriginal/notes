https://leetcode.com/explore/interview/card/top-interview-questions-easy/93/linked-list/553/
### Условие
Есть односвязный список `head`и мы хотим удалить узел `node`в нем.

Вам предоставлен узел, который нужно удалить. `node`. Вам **не будет предоставлен доступ** к первому узлу `head`.

Все значения связанного списка **уникальны** , и гарантируется, что данный узел `node`не последний узел в связанном списке.

Удалить заданный узел. Обратите внимание, что под удалением узла мы не подразумеваем его полное удаление из памяти. Мы имеем в виду:
- Значение данного узла не должно существовать в связанном списке.
- Количество узлов в связанном списке должно уменьшиться на один.
- Все значения до `node`должны быть в том же порядке.
- Все значения после `node`должны быть в том же порядке.
### Пример

**Ввод:** head = [4,5,1,9], node = 5
**Выход:** [4,1,9]

**Ввод:** head = [4,5,1,9], node = 1
**Выход:** [4,5,9]
### Решение

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode //создаем новую голову
    for head != nil {
        next := head.Next //сохраняем следующий элемент
        head.Next = prev //устанавливаем Next на новую голову
        prev = head // переставляем новую голову на новый элемент
        head = next // перемещаемся дальше по исходному списку
    }
    return prev
}
```

Рекурсивный вариант

```go
func reverseList(head *ListNode) *ListNode {
	// base case (случай, когда можно вычислить ответ напрямую)
	// и проверка на пустой список по совместительству
    if head == nil || head.Next == nil {
        return head
    }
    // запускаем рекурсию
    newHead := reverseList(head.Next)
    // разворачиваем список: устанавливаем свзязь(Next) 
    // следующего за текущим(head) элемента на текущий элемент
    head.Next.Next = head
    // по сути это надо только для первого (после разворота последнее)
    // элемента, чтобы разорвать его предыдущую связь
    head.Next = nil
    // возвращаем по цепочке указатель на новый начальный элемент
    return newHead
}
```