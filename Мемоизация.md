Рекурсия часто является интуитивно понятным и мощным способом реализации алгоритма. Однако при неразумном использовании она может привести к нежелательным потерям производительности, _например,_ к дублированию вычислений. Например, в конце предыдущей главы мы столкнулись с проблемой дублирования вычислений в треугольнике Паскаля, где некоторые промежуточные результаты вычисляются несколько раз.

Чтобы продемонстрировать ещё одну проблему с дублированием вычислений, рассмотрим пример, который, возможно, знаком большинству людей, [- число Фибоначчи](https://en.wikipedia.org/wiki/Fibonacci_number) . Если определить функцию `F(n)`для представления числа Фибоначчи в индексе `n`, то можно вывести следующее рекуррентное соотношение:

`F(n) = F(n - 1) + F(n - 2)`

с базовыми вариантами:

`F(0) = 0, F(1) = 1`

Учитывая определение числа Фибоначчи, функцию можно реализовать следующим образом:

```java
public static int fibonacci(int n) {
  if (n < 2) {
    return n;
  } else {
    return fibonacci(n-1) + fibonacci(n-2);
  }
}
```

Теперь, если вы хотите узнать количество `F(4)`, вы можете применить и расширить приведенные выше формулы следующим образом:

`F(4) = F(3) + F(2) = (F(2) + F(1)) + F(2)`

Как видите, чтобы получить результат для `F(4)`, нам потребуется вычислить число `F(2)`дважды, следуя приведенному выше вычету: первый раз в первом расширении `F(4)`и второй раз для промежуточного результата `F(3)`.

---

Чтобы исключить дублирование вычислений в приведенном выше случае, как многие из вас уже догадались, одной из идей было бы **сохранение** промежуточных результатов в кэше, чтобы мы могли использовать их повторно позже без повторных вычислений.

Эта идея также известна как _мемоизация_ — метод, который часто используется вместе с рекурсией.

> [Мемоизация](https://en.wikipedia.org/wiki/Memoization) — это метод оптимизации, используемый в основном для **ускорения работы** компьютерных программ путём **сохранения** результатов ресурсоёмких вызовов функций и возврата кэшированного результата при повторном использовании тех же входных данных. (Источник: Википедия)

Вернёмся к нашей функции Фибоначчи `F(n)`. Мы могли бы использовать хеш-таблицу для хранения результатов каждой функции, `F(n)`используя `n`хеш-таблицу в качестве ключа. Хеш-таблица служит кэшем, избавляющим нас от дублирования вычислений. Метод мемоизации — хороший пример того, как можно сократить время вычислений в обмен на дополнительное дисковое пространство.

Для сравнения ниже мы приводим реализацию решения чисел Фибоначчи с мемоизацией.

```java
import java.util.HashMap;

public class Main {

  HashMap<Integer, Integer> cache = new HashMap<Integer, Integer>();

  private int fib(int N) {
    if (cache.containsKey(N)) {
      return cache.get(N);
    }
    int result;
    if (N < 2) {
      result = N;
    } else {
      result = fib(N-1) + fib(N-2);
    }
    // keep the result in cache.
    cache.put(N, result);
    return result;
  }
}
```