
> Временная сложность рекурсивного алгоритма О(T) обычно является произведением **количества**  **_вызовов_** рекурсии (обозначается как R) и **временная сложность вычисления**  (обозначается как О(s)), которое происходит при каждом вызове рекурсии:
> О(T) = R * O(s)

Давайте рассмотрим несколько примеров ниже.

---
Как вы помните, в задаче printReverse нам нужно вывести строку в обратном порядке. Рекуррентное соотношение для решения этой задачи можно выразить следующим образом:

printReverse(str) = printReverse(str[1...n]) + print(str[0])

где str[1...n] — подстрока входной строки str без начального символа str[0].

Как видите, функция будет рекурсивно вызываться n раз, где n — размер входной строки. В конце каждой рекурсии мы просто выводим начальный символ, поэтому временная сложность этой конкретной операции является постоянной, т. е. O(1).

Подводя итог, общая временная сложность нашей рекурсивной функции printReverse(str) будет равна O(printReverse)=n∗O(1)=O(n).

---
Для рекурсивных функций редко бывает так, что количество рекурсивных вызовов линейно зависит от размера входных данных. Например, можно вспомнить пример числа Фибоначчи, рекуррентное соотношение которого определено как f(n) = f(n-1) + f(n-2). На первый взгляд, не кажется простым вычислить количество вызовов рекурсии во время выполнения функции Фибоначчи.

В этом случае лучше использовать дерево исполнения, которое используется для обозначения потока выполнения рекурсивной функции. Каждый узел в дереве представляет вызов рекурсивной функции. Таким образом, общее количество узлов в дереве соответствует количеству рекурсивных вызовов во время выполнения.

Дерево выполнения рекурсивной функции будет представлять собой n-арное дерево, где n — количество рекурсий, встречающихся в рекуррентном соотношении. Например, выполнение функции Фибоначчи будет представлять собой бинарное дерево, как видно из следующего графика, который показывает дерево выполнения для вычисления числа Фибоначчи f(4).

![[Pasted image 20251006152649.png]]

В полном двоичном дереве с n уровнями общее количество узлов будет равно 2^n − 1. Следовательно, верхняя граница (хотя и не строгая) для числа рекурсий в f(n) будет 2^n − 1. В результате мы можем оценить, что временная сложность для f(n) будет O(2^n).

Мемоизация

---
В предыдущей главе мы обсудили технику мемоизации, которая часто применяется для оптимизации временной сложности рекурсивных алгоритмов. Благодаря кэшированию и повторному использованию промежуточных результатов мемоизация может значительно сократить количество рекурсивных вызовов, то есть уменьшить количество ветвей в дереве выполнения. Это сокращение следует учитывать при анализе временной сложности рекурсивных алгоритмов с мемоизацией.

Вернёмся к нашему примеру с числом Фибоначчи. С помощью мемоизации мы сохраняем результат числа Фибоначчи для каждого индекса n. Мы уверены, что вычисление каждого числа Фибоначчи будет происходить только один раз. И мы знаем из рекуррентного соотношения, что число Фибоначчи f(n) будет зависеть от всех n-1 предшествующих чисел Фибоначчи. В результате рекурсия для вычисления f(n) будет вызываться n-1 раз для вычисления всех предшествующих чисел, от которых оно зависит.

Теперь мы можем просто применить формулу, которую мы ввели в начале этой главы, для вычисления временной сложности, которая равна O(1)∗n=O(n). Мемоизация не только оптимизирует временную сложность алгоритма, но и упрощает вычисление временной сложности.



