Строка представляет собой неизменяемую последовательность байтов. Из этого следует ряд выводов:

- к строке применимы операции, применимые к массивам и срезам;
- чтобы изменить строку, необходимо создать новую строку;
- мы можем итерироваться по строке как и по всякой последовательности, но итерируясь по строке, мы будем итерироваться по байтам, составляющим строку, а не по символам;
- мы можем определить в строке подстроку.

```go
func ExampleString() {
	// Создадим строковый литерал s, значение которого "Это строка".
	// Строка состоит из 10 символов.
	var s string = "Это строка"

	// Однако длина строки len(s) составит 19 байт, т.к. использованные кирилические символы
	// занимают 2 байта, а пробел занимает 1 байт.
	fmt.Printf("Длина строки: %d байт\n", len(s))

	// Посмотрим как взять подстроку
	fmt.Printf("Напечатаем только второе слово в кавычках: \"%v\"\n", s[7:])

	/*
		Попробуем изменить что-то встроке:
		s[3] = 12
		Ошибка компиляции: cannot assign to s[3], потому что строки - неизменяемые последовательности.
	*/

	// "Изменим строку", создав новую
	s = s + " Новая строка"
	fmt.Printf("%v\n", s)

	// А теперь проитерируемся по этой строке
	for _, b := range s {
		fmt.Printf("%v ", b)
	}
	fmt.Print("\n")

	// Output:
	// Длина строки: 19 байт
	// Напечатаем только второе слово в кавычках: "строка"
	// Это строка Новая строка
	// 1069 1090 1086 32 1089 1090 1088 1086 1082 1072 32 1053 1086 1074 1072 1103 32 1089 1090 1088 1086 1082 1072

}
```

В заключение скажем, что строки поддерживают проверку на равенство и неравенство, а вот проверки <> со строками уже не дадут нужного нам результата, т.к. сравнивать Go будет байты, а не символы, т.е. результат для нас может быть не тот, что мы ожидаем (сравнивается не длина строк):

### Основные функции для работы со строками

Go содержит большое количество функций для работы со строками в пакете `strings` , кратко рассмотрим основные: 

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println(    
        // Содержится ли подстрока в строке    
        strings.Contains("test", "es"), 
        // результат: true

        // Кол-во подстрок в строке
        strings.Count("test", "t"),
        // результат: 2

        // Начинается ли строка с префикса       
        strings.Contains("test", "es"), 
        // результат: true

        // Заканчивается ли строка суффиксом
        strings.HasSuffix("test", "st"), 
        // результат: true

        // Возвращает начальный индекс подстроки в строке, а при отсутствии вхождения возвращает -1
        strings.Index("test", "e"), 
        // результат: 1

        // объединяет массив строк через символ
        strings.Join([]string{"hello","world"}, "-"),
        // результат: "hello-world"

        // Повторяет строку n раз подряд
        strings.Repeat("a", 5), 
        // результат: "aaaaa"

        // Функция Replace заменяет любое вхождение old в вашей строке на new
        // Если значение n равно -1, то будут заменены все вхождения.
        // Общий вид: func Replace(s, old, new string, n int) string
        // Пример:
        strings.Replace("blanotblanot", "not", "***", 	-1),
        // результат: "bla***bla***"
 
        // Разбивает строку согласно разделителю
        strings.Split("a-b-c-d-e", "-"), 
        // результат: []string{"a","b","c","d","e"}

        // Возвращает строку c нижним регистром
        strings.ToLower("TEST"), 
        // результат: "test"

        // Возвращает строку c верхним регистром
        strings.ToUpper("test"), 
        // результат: "TEST"

        // Возвращает строку с вырезанным набором
        strings.Trim("tetstet", "te"),
        // результат: s
    )
}
```

![[Байтовые срезы (строки в Go)]]

![[Срезы рун (строки в Go)]]

## Количество символов в строке  
 
 Многие новички забывают что функция `len()` возвращает количество **байт** которое занимает строка, а не количество символов. Поэтому это будет работать только при использование латиницы и некоторых специальных символов (ASCII), так как они занимают 1 байт на 1 символ. А вот русские буквы уже занимают 2 байта на символ, мы можем это видеть в примере:

Для получения количества **символов** используйте `utf8.RuneCountInString()` 

```go
package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {
	var en = "english"
	var ru = "русский"
	fmt.Println(len(en), len(ru))
	fmt.Println(utf8.RuneCountInString(en), utf8.RuneCountInString(ru))
}
```

Вывод будет такой:

```
​​​​​​​7 14 // en -7 байтов, ru - 14 байтов
7 7 // а длина у строк одинаковая
```

==Более изящный способ определения длины строки в символах:==

`len([]rune(str))`

Это не требует импорта пакета "unicode/utf8". Что тут происходит? Любые символы (хоть иероглифы) загоняются в срез рун, где всегда будет соблюдаться принцип "1 символ = 1 элемент среза, четырехразрядное число". И сразу определяется длина среза.

Совет. Если строка вам нужна больше 1 раза, то запишите этот срез в переменную `strRunes := []rune(str)`. Делайте потом с ним, что хотите: range, измеряйте, меняйте местами буквы, перезаписывайте, добавляйте... Всякий раз, когда хотите снова из рун получить реальные символы - оберните элемент или весь срез в string():

```go
string(strRunes) //даст исходный текст

string(strRunes[i]) //даст і-тый символ
```

