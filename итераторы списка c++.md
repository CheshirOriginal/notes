[Итераторы](https://en.wikipedia.org/wiki/Iterator) — это специальные объекты, предназначенные для навигации по контейнеру. Итераторы позволяют обращаться к текущему элементу контейнера и сдвигаться к соседним элементам. Итератор, указывающий на начальный элемент контейнера, возвращает функция `begin`.

```c++
#include <iostream>
#include <list>

int main() {
    std::list<int> l = {10, 15, 20};

    // Используем auto, чтобы не писать громоздкий тип std::list<int>::iterator
    auto iter = l.begin();
    std::cout << *iter << "\n";  // печатаем начальный элемент
    ++iter;  // сдвигаемся к следующему элементу
    --iter;  // возвращаемся назад
}
```

Итераторы в C++ создавались по подобию указателей: их можно разыменовывать (`*`) и сдвигать (`++` и `--`). Однако операторы `++` и `--` для обычных указателей сдвигаются на соседние ячейки памяти, а двусвязный список хранит свои элементы разрозненно. Поэтому указатели могут подойти на роль итераторов лишь для контейнеров с непрерывным хранением (`array`, `vector` и `string`).

Функция `end` у контейнера возвращает особый итератор, который указывает _за_ последний элемент контейнера. Этот итератор нельзя разыменовывать. С ним можно только сравниваться:

```c++
#include <iostream>
#include <list>

int main() {
    std::list<int> l = {10, 15, 20};
    for (auto iter = l.begin(); iter != l.end(); ++iter) {
        std::cout << *iter << "\n";  // печатаем элементы списка через итератор
    }

    for (auto iter = l.rbegin(); iter != l.rend(); ++iter) {
        std::cout << *iter << "\n";  // проход по списку в обратном порядке
    }
}
```

С помощью итераторов можно вставлять ([`insert`](https://en.cppreference.com/w/cpp/container/list/insert)) или удалять ([`erase`](https://en.cppreference.com/w/cpp/container/list/erase)) элементы или целые цепочки элементов в любом месте списка:

```c++
#include <iostream>
#include <list>

int main() {
    std::list<int> l = {0, 10, 15, 20};

    auto iter = l.begin();
    ++iter;
    l.insert(iter, 5);  // вставляем на эту позицию элемент

    // Удаляем из списка чётные числа
    for (auto iter = l.begin(); iter != l.end(); ) {
        if (*iter % 2 == 0) {
            iter = l.erase(iter);  // возвращается итератор на элемент,
            // следующий за удалённым
        } else {
            ++iter;
        }
    }

}
```

Заметим, что к итераторам списка (в отличие от итераторов вектора) нельзя прибавлять произвольные целые числа, чтобы сдвинуть их на несколько позиций вперёд: эта операция не может быть реализована эффективно за константное время. Стандартная функция [`std::advance`](https://en.cppreference.com/w/cpp/iterator/advance) из заголовочного файла `iterator` умеет делать это за константное время для итераторов контейнеров с индексацией и за линейное время для итераторов списка. А функции [`std::next`](https://en.cppreference.com/w/cpp/iterator/next) и [`std::prev`](https://en.cppreference.com/w/cpp/iterator/prev) возвращают следующее и предыдущее значения итератора соответственно.

```c++
#include <iterator>
#include <list>

int main() {
    std::list<int> l = {0, 10, 15, 20};

    // вместо этого удобнее воспользоваться функцией std::next:
    // auto iter = l.begin();
    // ++iter;

    auto iter = std::next(l.begin());  // итератор указывает на второй элемент списка

    std::advance(iter, 2);  // итератор указывает на последний элемент
}
```