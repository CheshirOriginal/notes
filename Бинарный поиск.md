Основные шаблоны бинарного поиска:

### Шаблон 1

```c++
int binarySearch(vector<int>& nums, int target){
  if(nums.size() == 0)
    return -1;

  int left = 0, right = nums.size() - 1;
  while(left <= right){
    // чтобы предотвратить (left + right) overflow(переполнение)
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] < target) { left = mid + 1; }
    else { right = mid - 1; }
  }
  return -1;
}
```

Шаблон №1 — это самая простая и элементарная форма бинарного поиска. Это стандартный шаблон бинарного поиска, который большинство школ и университетов используют при первом обучении студентов информатике. Шаблон №1 используется для поиска элемента или условия, которое можно определить, _обратившись к одному индексу_ в массиве.

Особенности:
- Самая базовая и элементарная форма бинарного поиска
- Условие поиска можно определить без сравнения с соседними элементами (или использовать определенные элементы вокруг него)
- Постобработка не требуется, поскольку на каждом этапе вы проверяете, найден ли элемент. Если вы достигли конца, значит, элемент не найден.

### Шаблон 2

```c++
int binarySearch(vector<int>& nums, int target){
  if(nums.size() == 0)
    return -1;

  int left = 0, right = nums.size() - 1;
  while(left < right){
    // Prevent (left + right) overflow
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] < target) { left = mid + 1; }
    else { right = mid; }
  }

  // Постоброботка
  // Конечное условие: left == right
  if(nums[left] == target) return left;
  return -1;
}
```

Шаблон №2 — это расширенная форма бинарного поиска.

**Ключевые атрибуты:**

- Расширенный способ реализации бинарного поиска.
- Используйте правого соседа элемента, чтобы определить, выполняется ли условие, и решить, идти ли влево или вправо.
- Гарантирует, что размер поискового пространства составляет не менее 2 на каждом этапе
- Требуется постобработка. Цикл/рекурсия завершается, когда остаётся 1 элемент. Необходимо оценить, соответствует ли оставшийся элемент условию.

### Шаблон 3

```c++
int binarySearch(vector<int>& nums, int target){
    if (nums.size() == 0)
        return -1;

    int left = 0, right = nums.size() - 1;
    while (left + 1 < right){
        // Prevent (left + right) overflow
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid;
        } else {
            right = mid;
        }
    }

    // Постоброботка
    // Конечное условие: left + 1 == right
    if(nums[left] == target) return left;
    if(nums[right] == target) return right;
    return -1;
}
```

**Ключевые атрибуты:**

- Альтернативный способ реализации бинарного поиска
- Используйте соседей элемента, чтобы определить, выполняется ли условие, и решить, идти ли влево или вправо.
- Гарантирует, что размер поискового пространства составляет не менее 3 на каждом этапе
- Требуется постобработка. Цикл/рекурсия завершается, когда остаётся 2 элемента. Необходимо оценить, соответствуют ли оставшиеся элементы условию.