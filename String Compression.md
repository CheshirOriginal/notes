https://leetcode.com/problems/string-compression/description/
### Условие

Дан массив символов `chars`, сожмите его, используя следующий алгоритм:

Начните с пустой строки `s`. Для каждой группы **последовательно повторяющихся символов** в `chars`:

- Если длина группы равна `1`, добавьте символ к `s`.
- В противном случае добавьте символ, а затем длину группы.

Сжатую строку `s` **не следует возвращать отдельно** , а следует сохранять **во входном массиве символов`chars`** . Обратите внимание, что группы длиной , равной `10`или превышающей , будут разделены на несколько символов в `chars`.

После завершения **изменения входного массива** верните _новую длину массива_ .

Вам необходимо написать алгоритм, который использует только постоянное дополнительное пространство.

**Примечание:** Символы в массиве, выходящие за пределы возвращаемой длины, не имеют значения и должны игнорироваться.
### Пример
**Ввод:** chars = ["a","a","b","b","c","c","c"]
**Выход:** 6 (["a","2","b","2","c","3"])

**Ввод:** chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
**Выход:** 4 (["a","b","1","2"])
### Решение
```go
func compress(chars []byte) int {
    write, count := 0, 1

    for read := 1; read <= len(chars); read++ {
        if read < len(chars) && chars[read] == chars[read-1] {
            count++
            continue
        }

        // записываем символ
        chars[write] = chars[read-1]
        write++
  
        // если повторений больше 1, записываем число
        if count > 1 {
            start := write
            for n := count; n > 0; n /= 10 {
                chars[write] = byte(n%10) + '0'
                write++
            }
            // переворачиваем цифры (так как писали в обратном порядке)
            for l, r := start, write-1; l < r; l, r = l+1, r-1 {
                chars[l], chars[r] = chars[r], chars[l]
            }
        }
  
        count = 1
    }
    
    return write
}
```