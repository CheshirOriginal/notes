Функции позволяют отделить часто используемый код и переиспользовать его с разными значениями аргументов. С примером функции мы уже знакомы: в каждой программе вы пишете функцию `main`, которая не принимает аргументов и возвращает `int`.
## Примеры функций

Напишем простейшую функцию, вычисляющую сумму двух целых чисел:

```c++
int Sum(int a, int b) {  // в заголовке функции указывается тип возвращаемого значения и типы аргументов
    return a + b;
}
```

Если функция ничего не должна возвращать, её можно объявить как `void`:

```c++
void DoSomething(double d, char c) {
    // ...
    // писать return в конце такой функции не обязательно,
    //     но если требуется завершить функцию, можно написать просто return;
}

int main() {
    int x = 17, y = 42;
    int z = Sum(x, y);
    DoSomething(3.14, '@');
}
```
## Аргументы функций

==Параметры в функции по умолчанию передаются «по значению».== Другими словами, функция работает с копиями аргументов. 

==Можем ли мы изменить переданный аргумент внутри функции, чтобы это повлияло на аргументы в месте вызова? Да, для этого надо передать аргументы через ссылку или указатель.== Вот классический пример функции, меняющей два аргумента местами:

```c++
void Swap(int& x, int& y) {  // передаём аргументы по ссылке
    int z = x;
    x = y;
    y = z;
}

int main() {
    int a = 1, b = 2;
    Swap(a, b);
    std::cout << a << " " << b << "\n";  // 2 1
}
```

==Заметьте, что вызов `Swap(1, 2)`, в отличие от `Swap(a, b)`, не скомпилируется, потому что обычная ссылка должна быть привязана к изменяемому объекту.==

Иногда копирование объекта может быть очень дорогим (и ненужным). Например, копирование вектора приведёт к копированию всех его элементов. Поэтому вот так передавать вектор в функцию неэффективно:

```c++
void f(std::vector<int> v) {
    // плохо: при вызове функции создаётся копия вектора
}
```

Копии можно было бы избежать, если бы вектор передавался по ссылке:

```c++
void f(std::vector<int>& v) {
    // Но теперь есть другие недостатки:
    // 1. В такую функцию нельзя передать константный вектор.
    // 2. Функция не защищена от случайного изменения вектора:
    v.clear();  // тут компилятор нас не схватит за руку
}
```

==Поэтому самое правильное — передавать такой параметр по константной ссылке==:

```c++
void f(const std::vector<int>& v) {
    // Такой аргумент не требует дорогого копирования,
    // его нельзя случайно изменить внутри,
    // и такую функцию можно вызывать от констант!
}
```

==Давайте запомним: аргументы сложных типов (векторы, строки, любые контейнеры, большие структуры) всегда лучше передавать в функцию по константной ссылке, если функция использует их только для чтения. Из этого правила бывают исключения, но о них мы поговорим отдельно.==
## Возвращаемые значения функций

==В отличие от аргументов, значения сложных типов можно без проблем возвращать из функций.== Здесь от ненужного копирования (по крайней мере, для стандартных контейнеров) спасает [copy elision](https://en.cppreference.com/w/cpp/language/copy_elision).

Рассмотрим, например, функцию, которая возвращает конкатенацию всех строк из вектора:

```c++
#include <iostream>
#include <string>
#include <vector>

std::string Concatenate(const std::vector<std::string>& parts) {
    std::string result;
    for (const auto& part : parts) {
        result += part;
    }
    return result;
}

int main() {
    std::vector<std::string> parts = {"abra", "ca", "dabra"};
    std::cout << Concatenate(parts) << "\n";  // abracadabra
}
```

Опасно возвращать из функции ссылку на локальную переменную, так как эта ссылка сразу же станет «висячей»:

```c++
#include <iostream>

int& Sum(int a, int b) {  // ошибка!
    int result = a + b;
    return result;
}

int main() {
    std::cout << Sum(2, 3) << "\n";  // неопределённое поведение!
}
```

Компиляторы в таких случаях генерируют предупреждения.

Возвращать значение по ссылке можно только в случае, если оно заведомо будет доступно после завершения функции. Например, так можно вернуть глобальную переменную или аргумент, также переданный по ссылке.

## Функции-компараторы

Пусть имеется структура `Date`, описывающая день, месяц и год какой-то даты. Создадим вектор дат:

```c++
#include <algorithm>
#include <iostream>
#include <vector>

struct Date {
    int year = 1970;
    int month = 1;
    int day = 1;
};

int main() {
    std::vector<Date> dates = {
        {2020, 3, 15},
        {2019, 1, 21},
        {2021, 1, 30}
    };

    // напечатаем содержимое:
    for (const auto& [year, month, day] : dates) {
        std::cout << year << "." << month << "." << day << "\n";
    }
}
```

Предположим, нам требуется отсортировать даты. Для сортировки нам поможет уже знакомая функция `std::sort`, но есть нюанс: вызов `std::sort(dates.begin(), dates.end())` не скомпилируется, так как компилятор не умеет сравнивать даты между собой. Функция `std::sort` пытается найти оператор `<` для сравнения дат, но, увы, для нашей даты такого нет. Мы можем его определить. Он выглядит как функция с особым именем `operator <`, возвращающая `true`, если первый аргумент меньше второго:

```c++
bool operator < (const Date& lhs, const Date& rhs) {
    if (lhs.year != rhs.year) {
        return lhs.year < rhs.year;
    }
    if (lhs.month != rhs.month) {
        return lhs.month < rhs.month;
    }
    return lhs.day < rhs.day;
}
```

Здесь `lhs` и `rhs` — сокращения от left-hand side и right-hand side. Это левый и правый аргументы оператора `<`. Этот громоздкий код можно записать лаконичнее с использованием функции [`std::tie`](https://en.cppreference.com/w/cpp/utility/tuple/tie), возвращающей кортеж из ссылок, для которого уже определено лексикографическое (покомпонентное) сравнение:

```c++
bool operator < (const Date& lhs, const Date& rhs) {
    return std::tie(lhs.year, lhs.month, lhs.day) < std::tie(rhs.year, rhs.month, rhs.day);
}
```

После определения `operator <` сортировка заработает. Но что, если нам в разных случаях нужно по-разному сортировать даты — например, где-то в хронологическом порядке, а где-то — без учёта года? Можно передать в `std::sort` третьим аргументом свою функцию сравнения, которая будет использована вместо `operator <`:

```c++
bool CompareWithoutYear(const Date& lhs, const Date& rhs) {
    return std::tie(lhs.month, lhs.day) < std::tie(rhs.month, rhs.day);
}

int main() {
    // ...
    std::sort(dates.begin(), dates.end(), CompareWithoutYear);
}
```

Обратите внимание, что третьим аргументом в `std::sort` мы передаём саму функцию (без круглых скобок), а не результат её вызова от каких-то аргументов.

## Лямбда-функции

Иногда бывает неудобно определять отдельную именованную функцию для сравнения. Тогда можно определить анонимную [лямбда-функцию](https://en.cppreference.com/w/cpp/language/lambda) прямо в месте её использования:

```c++
#include <algorithm>
#include <vector>

struct Date {
    int year, month, day;
};

int main() {
    std::vector<Date> dates;
    std::sort(dates.begin(), dates.end(), [](const Date& lhs, const Date& rhs) {
        return std::tie(lhs.month, lhs.day) < std::tie(rhs.month, rhs.day);
    });
}
```

Тип возвращаемого значения тут не указывается, компилятор умеет его угадывать по `return` (его можно указать после круглых скобок на «питоновский» манер через `->`, но не обязательно).

Разберём синтаксис лямбда-функций. Тут видны три блока.

- Квадратные скобки отвечают за контекст. В них мы можем передать переменные, которые объявлены вне лямбда-функции через запятую, и они будут доступны в самой лямбда-функции.
- Круглые скобки отвечают за аргументы функции.
- Фигурные скобки отвечают за тело лямбда-функции.