### Понятие массива. Объявление и инициализация массива

Массив — это последовательность элементов одного типа фиксированной длины. Объявление массива осуществляется следующим образом:

```go
var a [3]int
fmt.Println(a) // [0 0 0]
```

При объявлении массива в квадратных скобках указывается его длина (length), которая совместно с типом элементов, определяет тип самого массива, т.е. [3]int не может просто так взаимодействовать с [5]int (массивы разной длины относятся к разным типам независимо от того, что хранят значения одного типа), также как не могут без приведения взаимодействовать int64 и int32.

Одновременно с объявлением массива мы можем задать значения его элементов (инициализировать его):

```go
var a [3]int = [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [...]int{1, 2, 3}
d := [3]int{1: 12}

fmt.Println(a) // [1 2 3]
fmt.Println(b) // [1 2 3]
fmt.Println(c) // [1 2 3]
fmt.Println(d) // [0 12 0]
```

### Сравнение массивов

Поскольку мы можем последовательно сравнить все элементы массива, мы можем сравнить и сами массивы:

```go
a := [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [3]int{3, 2, 1}

fmt.Println(a == b) // true
fmt.Println(a == c) // false
```

Но при этом нужно учитывать, что сравнимы только массивы одного типа (массивы одинаковой длины, содержащие элементы одинакового типа).

### Обращение к элементам массива. Индексы

Для обращения к элементам массива применяются индексы - номера элементов. При этом нумерация элементов массива начинается с нуля, то есть первый элемент будет иметь индекс 0. Индекс указывается в квадратных скобках. По индексу можно получить значение элемента, либо изменить его:

```go
package main

import "fmt"

func main() {   
    var numbers [5]int = [5]int{1,2,3,4,5}    

    fmt.Println(numbers[0])     // 1  
    fmt.Println(numbers[4])     // 5   

    numbers[0] = 87   

    fmt.Println(numbers[0])     // 87
}
```

При итерации по массиву мы можем использовать ключевое слово `range`, тогда цикл будет иметь следующий вид:

```go
a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for idx, elem := range a {
    fmt.Printf("Элемент с индексом %d: %d\n", idx, elem)
    // Элемент с индексом 0: 1
    // Элемент с индексом 1: 2
    // Элемент с индексом 2: 3
    // Элемент с индексом 3: 4
    // Элемент с индексом 4: 5
}
```

`Range` возвращает 2 объекта: индекс элемента в массиве и копию значения этого элемента. Любой из этих объектов должен быть опущен, если мы не планируем использовать его, для этого вместо имени переменной мы можем указать символ. Кроме того, если мы хотим использовать только индекс элемента, мы можем вообще не использовать второе возвращаемое значение:

```go
a := [5]int{1, 2, 3, 4, 5}

for idx := range a {
    fmt.Println(a[idx])
}

for idx, _ := range a {
    // В этом случае следует использовать приведенный выше вариант,
    // хотя технически эти варианты работают одинаково
    fmt.Println(a[idx])
}

for _, elem := range a {
    fmt.Println(elem)
}
```

Необходимо запомнить, что в качестве второго значения range возвращает копию элемента массива, это может быть важно, если в цикле мы хотим изменить массив. В этом случае мы должны обращаться к элементам массива по индексу:

```go
a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for _, elem := range a {
    elem = 100
    fmt.Println(elem)

    // 100
    // 100
    // 100
    // 100
    // 100
}
fmt.Println(a) // [1 2 3 4 5]

for idx := range a {
    a[idx] = 100
    fmt.Println(a[idx])

    // 100
    // 100
    // 100
    // 100
    // 100
}
fmt.Println(a) // [100 100 100 100 100]
```

В Go нет такой вещи, как передача по ссылке, вместо этого все передается по значению. Если присвоить значение массива другой переменной, то присваиваемое значение просто будет скопировано.

![[Pasted image 20240619181313.png]]

Если вы хотите передать лишь «ссылку» на массив, используйте указатели:

![[Pasted image 20240619181336.png]]



