Для создания небуферизированного канала вызывается функция `make()` без указания емкости канала:

```go
var intCh chan int = make(chan int) // канал для данных типа int

strCh := make(chan string) // канал для данных типа string
```

==Если канал пустой, то горутина-получатель блокируется, пока в канале не окажутся данные. Когда горутина-отправитель посылает данные, горутина-получатель получает эти данные и возобновляет работу.==

==Горутина-отправитель может отправлять данные только в пустой канал. Горутина-отправитель блокируется до тех пор, пока данные из канала не будут получены.== Например:

```go
package main
import "fmt"

func main() {
    intCh := make(chan int)
    go func() {
            fmt.Println("Go routine starts")
            intCh <- 5 // блокировка, пока данные не будут получены функцией main
    }()

    fmt.Println(<-intCh) // получение данных из канала
    fmt.Println("The End")
}
```

Через небуферизированный канал intCh горутина, представленная анонимной функцией, передает число 5:

```go
intCh <- 5
```

А функция main получает это число:

```go
fmt.Println(<-intCh)
```

Общий ход выполнения программы выглядит следующим образом:

1. Запускается функция main. Она создает канал intCh и запускает горутину в виде анонимной функции.
2. Функция main продолжает выполняться и блокируется на строке `fmt.Println(<-intCh)`, пока не будут получены данные.
3. Параллельно выполняется запущенная горутина в виде анонимной функции. В конце своего выполнения она отправляет даные через канал: `intCh <- 5`. Горутина блокируется, пока функция main не получит данные.
4. Функция main получает отправленные данные, деблокируется и продолжает свою работу.

В данном случае горутина определена в виде анонимной функции и поэтому она имеет доступ к окружению, в том числе к переменной intCh. Если же мы работаем с обычными функциями, то объекты каналов надо передавать через параметры:

```go
package main
import "fmt"

func main() {
    intCh := make(chan int)
    go factorial(5, intCh)  // вызов горутины
    
    fmt.Println(<-intCh) // получение данных из канала
    fmt.Println("The End")
}

func factorial(n int, ch chan int) {
    result := 1
    for i := 1; i <= n; i++ {
        result *= i
    }
    fmt.Println(n, "-", result)
    ch <- result // отправка данных в канал
}
```

Обратите внимание, как определяется параметр, который представляет канал данных типа int: `ch chan int`. Консольный вывод данной программы:

![[Pasted image 20240624140023.png]]

==Стоит отметить, что одномоментно одна горутина должна отправлять данные, а другая - получать. Например, если мы определим отправление и получение данных через канал в самой функции main, то мы столкнемся с взаимоблокировкой:==

```go
package main
import "fmt"

func main() {
    intCh := make(chan int)
    intCh <- 10 // функция main блокируется
    fmt.Println(<-intCh)
}
```

От этой ситуации следует отличать ситуацию, когда две горутины попеременно обмениваются данными, при этом одномоментно опять же одна горутина выступает отправителем, а другая - получателем. Например:

```go
package main
import "fmt"

func main() {
    intCh := make(chan int)
    go square(intCh) // square ожидает получения через канал
    intCh <- 4 // отправляем в канал число
    fmt.Println("result := ", <-intCh) // получаем из канала результат
    fmt.Println("The End")
}
// функция возведения в квадрат

func square(ch chan int) {
    num := <-ch // получаем из канала число
    fmt.Println("num := ", num)
    ch <- num * num // обратно отправляем квадрат числа

}
```

Здесь определена функция `square`, которая получает через канал число, возводит его в квадрат и возвращает обратно в канал. Функция main запускает функцию `square` в виде горутины, отправляет в канал некоторое число и ожидает получить в ответ из канала квадрат этого числа.

В итоге сначала запускается горутина square:

```go
go square(intCh)
```

Горутина square блокируется на строке

```go
num := <-ch
```

В этот момент получателем является горутина `square`, а отправителем функция `main`. И функция `main` отправляет данные в поток:

```go
intCh <- 4
```

После этого горутина `square` получает из канала число, и роли меняются: теперь отправителем становится горутина `square`, а получателем - функция `main`, которая в ожидании данных блокируется на строке:

```go
fmt.Println("result := ", <-intCh)
```

Функция `square` обрабатывает полученное число и отправляет квадрат числа в канал:

```go
ch <- num * num
```

Функция main получает из канала квадрат числа и завершает свою работу. Консольный вывод программы:

![[Pasted image 20240624141136.png]]