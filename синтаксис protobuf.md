### Базовые типы proto

Protobuf поддерживает использование многих стандартных примитивных типов, которые применяются в ряде наиболее популярных языков программирования:

| Тип proto                                                          | Тип Go  |
| ------------------------------------------------------------------ | ------- |
| double                                                             | float64 |
| float                                                              | float32 |
| int32 (только для положительных чисел)                             | int32   |
| int64 (только для положительных чисел)                             | int64   |
| uint32                                                             | uint32  |
| uint64                                                             | uint64  |
| sint32                                                             | int32   |
| sint64                                                             | int64   |
| fixed32                                                            | uint32  |
| fixed64                                                            | uint64  |
| sfixed32                                                           | int32   |
| sfixed64                                                           | int64   |
| bool                                                               | bool    |
| string                                                             | string  |
| bytes (произвольная последовательность байтов длиной не более 232) | []byte  |
Типы int32 и int64 применяются преимущественно для положительных чисел, а для отрицательных лучше применять соответственно sint32 и sint64.

При парсинге сообщения если для какого-то поля сообщения не отсутствует значение, то это поле получает значение по умолчанию: для строк - пустая строка, для чисел - 0, для bool - false.
### Определение сообщений

Для передачи данных в Protobuf используются сообщения. Определение сообщения начинается с ключевого слова message, за которым следует имя сообщения.

```
message имя_сообщения {}
```

Далее внутри фигурных скобок помещаются поля сообщения. Поля определяются в формате:

```
тип имя = значение;
```

Например, определим сообщение Person с двумя полями `name` и `age`:

```Protobuf
message Person {
	string name = 1;
	int32 age = 2;
}
```

В качестве значения каждому полю передается уникальный номер для идентификации каждого поля при сериализации сообщения. Собственно поэтому каждое поле в рамках сообщения должно иметь уникальное числовое значение. Причем при использовании чисел от 1 до 15 в качестве значения в бинаром представлении в сообщение добавляется дополнительный байт. Значения от 16 до 2047 добавляют два дополнительных байта. Поэтому для наиболее часто используемых в сообщении данных лучше указывать значения от 1 до 15. Допустимые значения: от 1 до 536870911 (за исключением диапазона чисел от 19000 до 19999).

В качестве типов поле сообщений также могут выступать не только примитивные типы Protobuf, но и другие сообщения.

Стоит отметить, что стайлгайд для Protobuf рекомендует использовать для именования полей так называемый "snake_case" (змеиный_регистр), при котором в составном имени составные части разделяются прочерком, например, "first_name". 

Префикс `repeated` у поля означает, что этот тип поля может повторяться ноль или более раз в корректно сформированном сообщении. Порядок повторяющихся значений будет сохранен.
### Nullable-типы

Для определения полей, которые допускают значение null, в Protobuf доступны типы-обертки:

| Тип Go  | Тип Protobuf                |
| ------- | --------------------------- |
| bool    | google.protobuf.BoolValue   |
| float64 | google.protobuf.DoubleValue |
| float32 | google.protobuf.FloatValue  |
| int32   | google.protobuf.Int32Value  |
| int64   | google.protobuf.Int64Value  |
| uint32  | google.protobuf.UInt32Value |
| uint64  | google.protobuf.UInt64Value |
| string  | google.protobuf.StringValue |
| []byte  | google.protobuf.BytesValue  |

Для их использования в файле `.proto` необходимо импортировать файл wrappers.proto

```Protobuf
import "google/protobuf/wrappers.proto";

message Person{
    google.protobuf.StringValue name = 1;
    google.protobuf.Int32Value age = 2;

}
```

### Перечисления

При определении типа сообщения может потребоваться, чтобы одно из его полей принимало только одно значение из предопределённого списка. Например, вы хотите добавить поле корпуса для каждого SearchRequest, где корпус может быть следующим: UNIVERSAL, WEB, IMAGES, LOCAL, NEWS, PRODUCTS или VIDEO. Это можно сделать очень просто, добавив перечисление к определению сообщения с константой для каждого возможного значения.

В следующем примере мы добавили перечисление с именем Corpus со всеми возможными значениями и поле типа Corpus:

```Protobuf
enum Corpus {
  CORPUS_UNSPECIFIED = 0;
  CORPUS_UNIVERSAL = 1;
  CORPUS_WEB = 2;
  CORPUS_IMAGES = 3;
  CORPUS_LOCAL = 4;
  CORPUS_NEWS = 5;
  CORPUS_PRODUCTS = 6;
  CORPUS_VIDEO = 7;
}

message SearchRequest {
  string query = 1;
  int32 page_number = 2;
  int32 results_per_page = 3;
  Corpus corpus = 4;
}
```

Значение по умолчанию для поля SearchRequest.corpus — CORPUS_UNSPECIFIED, поскольку это первое значение, определенное в перечислении.

### Импорт определений

Вы можете использовать определения из других файлов .proto, импортируя их. Чтобы импортировать определения из другого файла .proto, добавьте оператор импорта в начало файла:

```protobuf
import "myproject/other_protos.proto";
```

### Вложенные типы

Вы можете определять и использовать типы сообщений внутри других типов сообщений, как в следующем примере — здесь сообщение Result определяется внутри сообщения SearchResponse:

```protobuf
message SearchResponse {
  message Result {
    string url = 1;
    string title = 2;
    repeated string snippets = 3;
  }
  repeated Result results = 1;
}
```

Если вы хотите повторно использовать этот тип сообщения вне его родительского типа сообщения, вы ссылаетесь на него как _Parent_._Type_:

```protobuf
message SomeOtherMessage {
  SearchResponse.Result result = 1;
}
```

Вы можете вкладывать сообщения так глубоко, как вам нужно.
### Определение сервиса

Сервис определяется с помощью ключевого слова service, после которого идет имя сервиса:

```
sercice имя {}
```

Тело сервиса составляют функции, которые определяются с помощью ключевого слова rpc

```
rpc имя_функции (входящее_сообщение) returns (отправляемое_сообщение);
```

После rpc идет имя_функции, а затем в скобках тип сообщения, которое получает сервис. Далее после оператора returns - тип сообщения, которое возвращает сервис.

```Protobuf
service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}
```

Сервис может содержать множество функций, но стоит учитывать, что она обязательно должно принимать какое-то сообщение и возвращать какое-нибудь сообщения. Но при необходимости можно создавать также пустые сообщения.

```Protobuf
service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
  rpc Test (VoidRequest) returns (TestResponse);
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}

// пустое сообщение запроса

message VoidRequest{ }

message TestResponse{
    string text = 1;
}
```

#### Типы методов

Сервисы gRPC может определять различные типы методов. От типа методов зависит, как сервис будет получать и отправлять сообщения. Поддерживаются следующие типы методов:

- Унарные (сервис отправляет и получает обычное сообщение)

- Потоковая передача сервера (сервер получает обычное сообщение, а отправляет поток)

- Потоковая передача клиента (сервер получает поток данных, а отправляет обычное сообщение

- Двунаправленная потоковая передача (сервер получает поток данных и отправляет поток данных)

Потоки определяются с помощью ключевого слова stream, которое ставится перед названием сообщения:

```Protobuf
syntax = "proto3";

service ExampleService {
  // унарный метод
  rpc UnaryCall (ExampleRequest) returns (ExampleResponse);
  
  // Потоковая передача сервера
  rpc StreamingFromServer (ExampleRequest) returns (stream ExampleResponse);
  
  // Потоковая передача клиента
  rpc StreamingFromClient (stream ExampleRequest) returns (ExampleResponse);
  
  // Двунаправленняя потоковая передача
  rpc StreamingBothWays (stream ExampleRequest) returns (stream ExampleResponse);
}
```

