==Массив представляет собой основную структуру данных смежного типа.== Записи дан­ных в массивах имеют постоянный размер, что позволяет с легкостью найти любой элемент по его индексу (или адресу).

Основные достоинства массивов:  

+ ==Постоянное время доступа при условии наличия индекса.== Так как индекс каждого элемента массива соответствует определенному адресу в памяти, то при наличии соответствующего индекса доступ к произвольному эле­ менту массива осуществляется практически мгновенно.  
+ ==Эффективное использование памяти.== Массивы содержат только данные, поэтому память не тратится на указатели и дру­гую форматирующую информацию. Кроме этого, для элементов массива не требу­ется использовать метку конца записи, поскольку все элементы массива имеют оди­наковый размер.
+ ==Локальность в памяти.== Во многих задачах программирования требуется обрабатывать элементы структуры данных в цикле. Массивы хорошо подходят для операций такого типа, поскольку обладают отличной локальностью в памяти. В современных компьютерных архи­тектурах физическая непрерывность последовательных обращений к данным помо­гает воспользоваться высокоскоростной кэш-памятью.

==Недостатком массивов== является то, что их размер нельзя изменять в процессе исполне­ния программы. Попытка обращения к (n + l )-му элементу массива размером n элемен­тов немедленно вызовет аварийное завершение программы.

==В действительности, размеры массива можно изменять во время исполнения програм­мы посредством приема, называющегося динамическим выделением памяти.== Допус­тим, мы начнем с одноэлементного массива размером m и будем удваивать его каждый раз до 2m, когда предыдущий размер становится недостаточным. Этот процесс состоит из выделения памяти под новый непрерывный массив размером 2m, копирования со­держимого старого массива в нижнюю половину нового и возвращения памяти старого массива в систему распределения памяти. Очевидным расточительством в этой процедуре является операция копирования со­держимого старого массива в новый при каждом удвоении размера массива. Это поро­ждает вопрос: какой объем работы нужно на самом деле выполнить? Чтобы получить в массиве n позиций, потребуется log 2n (или lg n) удвоений, плюс еще одно последнее удвоение на последней вставке, когда n = 2j для некоторых значений j. Операции по­вторного копирования выполняются после первой, второй, четвертой, восьмой, ... , n-й вставок. На i-м удвоении количество операций копирования будет 2i - 1, поэтому общее количество перемещений M будет равно:

![[ViVM7bZBS0w.jpg]]

==Таким образом, каждый из n элементов массива в среднем перемещается только два раза, а общая временная сложность управления динамическим массивом определяется той же самой функцией О(n)==, какая справедлива для работы с одним статическим мас­сивом достаточного размера.

==Самой главной проблемой при использовании динамических массивов является отсут­ствие гарантии постоянства времени выполнения каждой вставки в наихудшем случае.== Теперь же все обращения и большинство вставок будут быстрыми, за исключением тех относительно нечастых вставок, вызывающих удвоение массива. ==Зато у нас есть уве­ренность, что вставка n-го элемента в массив будет выполнена достаточно быстро, что­ бы общее затраченное усилие осталось таким же О(n).== Такие амортизированные гаран­тии часто возникают при анализе структур данных.


