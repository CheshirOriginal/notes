
### Условие

Вам дан массив интервалов времени встреч, где каждый интервал представлен как `intervals[i] = [start_i, end_i]`. Каждый интервал указывает время начала и окончания встречи.

Ваша задача — найти минимально необходимое количество конференц-залов для планирования всех встреч без накладок. Другими словами, если две или более встреч совпадают по времени, им нужны отдельные конференц-залы.
### Пример

Например, если у вас есть встречи `[[0,30],[5,10],[15,20]]`Первая встреча проходит с 0 по 30. Вторая встреча (с 5 по 10) совпадает с первой, поэтому вам понадобится вторая комната. Третья встреча (с 15 по 20) также совпадает с первой, но, поскольку вторая встреча уже закончилась к 15, вы можете использовать эту комнату. Следовательно, вам потребуется как минимум две переговорные комнаты.
### Решение
Рабочий, но не идеальный вариант
```c++
class Solution {  
public:  
    int minMeetingRooms(vector<vector<int>>& intervals) {  
        // Находим максимальное время окончания среди всех интервалов.
        int maxEndTime = 0;  
        for (const auto& interval : intervals) {  
            maxEndTime = max(maxEndTime, interval[1]);  
        }  
        // Создаем массив разностей для отслеживания изменений в
        // конференц-зале в каждый момент времени.
        // differArray[i] представляет изменение количества встреч в
        // момент времени i        
        vector<int> differenceArray(maxEndTime + 1, 0);  
        // Отмечаем начало и конец каждой встречи в массиве разностей  
        // +1 во время начала означает, что встреча начинается 
        // (нужна еще одна комната)        
        // -1 в конце означает, что встреча заканчивается 
        // (освободилась одна комната)
        for (const auto& interval : intervals) {  
	        differenceArray[interval[0]]++;  
            differenceArray[interval[1]]--;  
        }  
        // Рассчитайте максимальное количество одновременных встреч
        int maxRooms = 0;  
        int currentRooms = 0;  
        // Проходимся по массиву differenceArray и накапливаем
        // количество активных встреч
        for (int change : differenceArray) {  
            currentRooms += change;  
            maxRooms = max(maxRooms, currentRooms);  
        }  
        return maxRooms;  
    }  
};
```

Текущее решение создает массив размером `max_end_time + 1`, что может быть крайне неэффективно при работе с большими временными значениями. Например, если у вас есть встречи, такие как `[[1000000, 1000005], [1000002, 1000007]]`, решение создаст массив из более чем 1 миллиона элементов только для отслеживания нескольких встреч.
В качестве решения можно использовать словарь вместо массива.

```cpp
class Solution {  
public:  
    int minMeetingRooms(vector<vector<int>>& intervals) {   
        // Создаем словарь разностей для отслеживания изменений в
        // конференц-зале в каждый момент времени.
        // mp[i] представляет изменение количества встреч в
        // момент времени i        
        map<int, int> mp;
        // Отмечаем начало и конец каждой встречи в словаре разностей  
        // +1 во время начала означает, что встреча начинается 
        // (нужна еще одна комната)        
        // -1 в конце означает, что встреча заканчивается 
        // (освободилась одна комната)
        for (auto& i : intervals) {  
		    mp[i[0]]++;  
		    mp[i[1]]--;  
		} 
        // Рассчитайте максимальное количество одновременных встреч
        int maxRooms = 0;  
        int currentRooms = 0;  
        // Проходимся по словарю mp и накапливаем количество
        // активных встреч
        for (auto& [key, value] : mp) {  
		    currentRooms += value;  
		    maxRooms = max(maxRooms, currentRooms);  
		}
        return maxRooms;  
    }  
};
```