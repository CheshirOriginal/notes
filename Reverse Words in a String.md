
https://leetcode.com/explore/learn/card/array-and-string/204/conclusion/1164
### Условие
Дана входная строка `s`, поменяйте порядок **слов** на обратный .

Слово **.** определяется как последовательность символов, не являющихся пробелами **Слова** в `s`будут разделены как минимум одним пробелом.

Возвращает _строку слов в обратном порядке, соединенных одним пробелом._

**Обратите внимание** , что `s` Может содержать начальные или конечные пробелы, а также несколько пробелов между двумя словами. Возвращаемая строка должна содержать только один пробел, разделяющий слова. Не добавляйте лишние пробелы.
### Пример

**Ввод:** s = "the sky is blue"
**Выход:** "blue is sky the"

**Ввод:** s = "  hello world  "
**Выход:** "world hello"
### Решение

```go
func reverseWords(s string) string {
    res := make([]byte, len(s))
    counter := 0
    resIdx := 0
    
    for i := len(s) - 1; i >= 0; i-- {
        if s[i] != ' ' {
            counter++
            continue
        } else if counter > 0 {
            for j := i + 1; j <= i + counter; j++ {
                res[resIdx] = s[j]
                resIdx++
            }
            res[resIdx] = ' '
            resIdx++
            counter = 0
        }
    }
    if counter > 0 {
        for j := 0; j < counter; j++ {
            res[resIdx] = s[j]
            resIdx++
        }
    }
    
    if res[resIdx-1] == ' ' {
        return string(res[:resIdx-1])
    }
    return string(res[:resIdx])
}
```

### Принцип 

Не уверен, что решение хорошее, но по сути линейное время (по аналогии со скользящим окном) и пространство (в go по другому нельзя, так как строка это неизменяемый тип) неплохой результат.

Принцип банальный: идем с конца по входной строке и ищем полное слово по разделительным пробелам, если нашли переписываем в результирующий срез байт.


