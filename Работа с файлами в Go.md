[[Язык GoLang]]
###  io/ioutil

Пакет [io/ioutil](https://golang.org/pkg/io/ioutil/) предоставляет скромные, но наиболее востребованные возможности по чтению и записи файлов. Вот практически все содержащиеся в пакете функции:

```go
func ReadFile(filename string) ([]byte, error)

func WriteFile(filename string, data []byte, perm os.FileMode) error
```

Из сигнатуры этих функций все должно быть предельно ясно: функции реализуют чтение и запись файла, данные считываются / записываются в формате байтового среза. Единственное, что может быть не так очевидно, это параметр perm типа os.FileMode – это права доступа к файлу в битовом формате, знакомом всем, кто знаком с операционными системами \*nix.

Следующая функция, которую мы можем использовать:

```go
func ReadAll(r io.Reader) ([]byte, error)
```

Здесь в качестве аргумента передается не имя файла, а объект типа io.Reader, соответственно функция может читать данные из всех объектов, удовлетворяющих указанному интерфейсу: в т.ч. сетевые соединения и буферы:

```go
b := bytes.NewReader([]byte("Данные в объекте io.Reader"))

data, err := ioutil.ReadAll(b)
if err != nil {
	// ...
}

fmt.Printf("%s\n", data) // Данные в объекте io.Reader
```

Последняя функция позволяет получить информацию о содержании директории:

```go
func ReadDir(dirname string) ([]os.FileInfo, error)
```

Не думаю, что в этом вопросе могут возникнуть какие-то проблемы, поэтому просто приведу ряд примеров:

```go
dataForFile := []byte("Тестовая строка, предназначенная для записи в файл")

// Создаем новый файл и записываем в него данные dataForFile
if err := ioutil.WriteFile("test.txt", dataForFile, 0600); err != nil {
	...
}

// Читаем данные из того же файла
dataFromFile, err := ioutil.ReadFile("test.txt")
if err != nil {
	...
}

// Сравниваем исходные данные с записанными в файл и прочитанными из него
fmt.Printf("dataForFile == dataFromFile: %v\n", bytes.Equal(dataFromFile, dataForFile))

// Изучаем содержимое директории
filesFromDir, err := ioutil.ReadDir(".")
if err != nil {
	...
}

for _, file := range filesFromDir {
	// Проходим по всем найденным файлам и печатаем их имя и размер
	fmt.Printf("name: %s, size: %d\n", file.Name(), file.Size())
}

// Output:
// dataForFile == dataFromFile: true
// name: main.go, size: 727
// name: test.txt, size: 93
```

### os

Следующий пакет, который мы просто обязаны рассмотреть, это пакет [os](https://golang.org/pkg/os/). Он содержит огромный набор высокоуровневых инструментов для работы с файлами (и не только).

Для начала мы должны отметить, что рассматриваемый пакет сам не предоставляет удобных инструментов для чтения и записи в файл, хотя теоретически чтение и запись возможны. Центром пакета является объект os.File, который реализует ряд интерфейсов, в т.ч. Reader и Writer. Таким образом для удобной работы с данным типом нам может потребоваться что-то еще, например для чтения всего файла может быть использована функция ReadAll из ранее рассмотренного пакета io/ioutil. Для создания рассматриваемого объекта мы можем использовать ряд предлагаемых пакетом функций:

```go
func Create(name string) (*File, error) // создание файла с именем name

func Open(name string) (*File, error) // открытие файла с именем name
```

Данный объект имеет ряд методов, позволяющих вернуть имя файла, изменить права доступа или владельца файла. Нас же, прежде всего, будет интересовать метод Close(), который должен быть вызван при закрытии файла, чтобы освободить занятые нашей программой ресурсы операционной системы. Чтобы быть уверенными, что файл будет закрыт, а ресурсы освобождены даже в случае критической непредвиденной ошибки, рекомендуется сразу после проверки, что файл создан / открыт запланировать его закрытие с помощью оператора отложенного вызова defer:

```go
f, err := os.Open("fileName")
if err != nil {
	...
}
defer f.Close()
```

С имеющимися методами данного типа вы можете ознакомиться в документации, примеры же работы с этим объектом мы приведем в следующем шаге, когда рассмотрим более удобные способы работы с этим типом.  
  
Переименование и удаление файлов делается через функции Rename и Remove:

```go
// создаем файл
os.Create("text.txt")
// переименовываем файл
os.Rename("text.txt", "new_text.txt")
// удаляем файл
os.Remove("new_text.txt")
// кстати, os позволяет работать не только с файлами
// выходим из программы:
os.Exit(0)
```

Так же мы можем получать информацию файлов и сравнивать их:

```go
file1, _ := os.Create("text.txt")
file2, _ := os.Create("text.txt")
info1, _ := file1.Stat() // функция Stat возвращает информацию о файле и ошибку
info2, _ := file2.Stat()
fmt.Println(os.SameFile(info1, info2)) // true

// вот что мы можем получить из FileInfo:
// A FileInfo describes a file and is returned by Stat and Lstat.
type FileInfo interface {
	Name() string       // base name of the file
	Size() int64        // length in bytes for regular files; system-dependent for others
	Mode() FileMode     // file mode bits
	ModTime() time.Time // modification time
	IsDir() bool        // abbreviation for Mode().IsDir()
	Sys() interface{}   // underlying data source (can return nil)
}
```

Также существует удобная функция WriteString у файлов которая записывает строки в конце файла. Например, нужно открыть существующий файл с какой-то информацией и записать, не затрагивая старую.

```go
file1, _ := os.Create("text.txt")
file1.WriteString("1 строка \n")
file1.WriteString("2 строка \n")
file1.Close()

// внутри файла будет:
// 1 строка 
// 2 строка 
```

###  bufio

Пакет [bufio](https://golang.org/pkg/bufio/) предоставляет нам ряд инструментов для удобного чтения и записи информации из объектов, удовлетворяющих интерфейсам `io.Reader` и `io.Writer`. Нас в этом вопросе прежде всего будут интересовать типы `bufio.Reader`, `bufio.Writer` и `bufio.Scanner`.
#### bufio.Reader
Данный тип создается с помощью функций:

```go
func NewReader(rd io.Reader) *Reader // создает Reader со стандартным буфером 4096 байт

func NewReaderSize(rd io.Reader, size int) *Reader // создает Reader с произвольным буфером
```

Рассмотрим некоторые из методов bufio.Reader и примеры работы:

```go
file, err := os.Open("test.txt")
if err != nil {
	...
}
defer file.Close()

rd := bufio.NewReader(file)

buf := make([]byte, 10)
n, err := rd.Read(buf) // читаем в buf 10 байт из ранее открытого файла
if err != nil && err != io.EOF {
	// io.EOF не совсем ошибка - это состояние, указывающее, что файл прочитан до конца
	...
}
fmt.Printf("прочитано %d байт: %s\n", n, buf) // прочитано 10 байт: bufio ...

s, err := rd.ReadString('\n') // читаем данные до разрыва абзаца ('\n')
fmt.Printf("%s\n", s)         // ... здесь будет строка
```

`bufio.Reader` позволяет читать данные по байтам, рунам, строкам и пр., указывать символ, на котором необходимо прекратить чтение. Когда данные будут прочитаны до конца, метод вернет ошибку io.EOF.

#### bufio.Writer

`bufio.Writer` создан для записи в объекты, удовлетворяющие интерфейсу io.Writer, но предоставляет ряд более высокоуровневых методов, в частности метод WriteString(s string):

```go
file, err := os.Create("test.txt")
if err != nil {
	...
}
defer file.Close()

w := bufio.NewWriter(file)
n, err := w.WriteString("Запишем строку")
if err != nil {
	...
}
fmt.Printf("Записано %d байт\n", n) // Записано 27 байт

// bufio.Writer имеет собственный буфер, чтобы быть уверенным, что данные точно записаны,
// вызываем метод Flush()
w.Flush()
```

#### bufio.Scanner

`bufio.Scanner` создан для построчного чтения данных. Создается он функцией `NewScanner(r io.Reader)`, посмотрим, как работает этот тип:

```go
file, err := os.Open("test.txt")
if err != nil {
	panic(err)
}
defer file.Close()

s := bufio.NewScanner(file)

// Я заранее записал в файл 5 цифр, каждую на новой строке
for s.Scan() { // возвращает true, пока файл не будет прочитан до конца
	fmt.Printf("%s\n", s.Text()) // s.Text() содержит данные, считанные на данной итерации
}

// 1
// 2
// 3
// 4
// 5
```

### В каких случаях использовать тот или иной пакет стандартной библиотеки

В качестве небольшого отступления рассмотрим вопрос о целесообразности использования того или иного метода чтения / записи. Если объем данных небольшой, то разумно использовать функции из пакета io/ioutil - они позволяют нам не заботиться о закрытии файла (кроме функции ReadAll, которая в качестве аргумента получает тип io.Reader), кроме того, все данные считываются / записываются за раз. Стоит дополнить, что многие методы io/ioutil это просто удобные обертки (абстракции) под капотом которых тот же os.OpenFile и тд. Поэтому если хочется более близкий доступ к системе и возможностям используйте os.

Но что если объем данных велик, или не все данные используются единовременно (или готовятся к записи постепенно)? Тогда правильно будет отдать предпочтение пакету bufio, который может считывать данные поэтапно, в т.ч. построчно, записывать данные постепенно.
### encoding/csv

Пакет `encoding/csv` предоставляет нам типы `csv.Reader` и `csv.Writer`, предназначенные соответственно для чтения и записи файлов в формате csv. По умолчанию разделителем столбцов выступает символ ",". Поскольку работа с этими объектами довольно тривиальна, рассмотрим ее на примерах, не думаю, что могут возникнуть какие-то проблемы с их пониманием:

```go
// Записывать данные, а в дальнейшем читать их мы будем из буфера,
// но его можно заменить любым другим объектом, удовлетворяющим
// интерфейсу io.ReadWriter
buf := bytes.NewBuffer(nil)

w := csv.NewWriter(buf)

for i := 1; i <= 3; i++ {
	// Запись данных может производится поэтапно, например в цикле
	val1 := fmt.Sprintf("row %d col 1", i)
	val2 := fmt.Sprintf("row %d col 2", i)
	val3 := fmt.Sprintf("row %d col 3", i)
	if err := w.Write([]string{val1, val2, val3}); err != nil { 
		// Аргументом Write является срез строк
		// ...
	}
}
w.Flush() // Этот метод приведет к фактической записи данных из буфера csv.Writer в buf

// Либо данные можно записать за один раз
w.WriteAll([][]string{ // Аргументом WriteAll является срез срезов строк
	{"row 4 col 1", "row 4 col 2", "row 4 col 3"},
	{"row 5 col 1", "row 5 col 2", "row 5 col 3"},
})

r := csv.NewReader(buf)

for i := 1; i <= 2; i++ {
	// Читать данные мы тоже можем построчно, получая срез строк за каждую итерацию
	row, err := r.Read()
	if err != nil && err != io.EOF { // Здесь тоже нужно учитывать конец файла
		// ...
	}
	fmt.Println(row)
}

// Либо прочитать данные за один раз
data, err := r.ReadAll()
if err != nil {
	// Когда мы читаем данные до конца файла io.EOF не возвращается, а служит сигналом к завершению чтения
	// ...
}

for _, row := range data {
	fmt.Println(row)
}

// [row 1 col 1 row 1 col 2 row 1 col 3]
// [row 2 col 1 row 2 col 2 row 2 col 3]
// [row 3 col 1 row 3 col 2 row 3 col 3]
// [row 4 col 1 row 4 col 2 row 4 col 3]
// [row 5 col 1 row 5 col 2 row 5 col 3]
```

Соответственно при сравнительно небольшом объеме данных они могут быть прочитаны или записаны за один раз, большой объем данных или их поэтапная обработка могут быть проведены в цикле, условием выхода из цикла может быть получение ошибки io.EOF (для чтения данных).
### path и path/filepath

В завершении мы кратко остановимся на двух пакетах, реализующих функционал создания и обработки путей к файлам [path](https://golang.org/pkg/path) и [path/filepath](https://golang.org/pkg/path/filepath/).

Пакет path использует в качестве разделителя символ "/" (слэш), как следствие, он может использоваться только в операционных системах с соответствующим разделителем - [unix системах](https://ru.wikipedia.org/wiki/Unix-%D0%BF%D0%BE%D0%B4%D0%BE%D0%B1%D0%BD%D0%B0%D1%8F_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0) (MaсOS, GNU/Linux и другие). Второй же пакет более универсален и выбирает разделитель в зависимости от операционной системы: для Windows используется обратный слэш - "\".

Оба пакета содержат достаточное количество примеров их работы, мы же остановимся на функции Walk из пакета path/filepath:

```go
func Walk(root string, walkFn WalkFunc) error

// root - директория, с которой начинается обход
// walkFn - функция вида func(path string, info os.FileInfo, err error) error
```

Итак, что же происходит в работе этой функции: Walk рекурсивно обходит все файлы и директории начиная с директории root и для каждого файла (а директория - тоже файл) выполняет функцию walkFn. Давайте рассмотрим работу этой функции на примере:

_Я заранее создал набор директорий и файлов:_

_._  
_├── dir1  
│   ├── file1  
│   └── file2  
├── dir2  
│   └── file3  
└── dir3  
    ├── file4  
    ├── file5  
    └── file6_  
Давайте соберем информацию о всех файлах:

```go
package main

import (
	"fmt"
	"os"
	"path/filepath"
)

func walkFunc(path string, info os.FileInfo, err error) error {
	if err != nil {
		return err // Если по какой-то причине мы получили ошибку, проигнорируем эту итерацию
	}

	if info.IsDir() {
		return nil // Проигнорируем директории
	}

	fmt.Printf("Name: %s\tSize: %d byte\tPath: %s\n", info.Name(), info.Size(), path)
	return nil
}

func main() {
	const root = "./test" // Файлы моей программы находятся в другой директории

	if err := filepath.Walk(root, walkFunc); err != nil {
		fmt.Printf("Какая-то ошибка: %v\n", err)
	}

	// Name: file1     Size: 6 byte    Path: test/dir1/file1
	// Name: file2     Size: 6 byte    Path: test/dir1/file2
	// Name: file3     Size: 6 byte    Path: test/dir2/file3
	// Name: file4     Size: 6 byte    Path: test/dir3/file4
	// Name: file5     Size: 6 byte    Path: test/dir3/file5
	// Name: file6     Size: 6 byte    Path: test/dir3/file6
}
```

Размер файлов одинаков, но это не ошибка. Как вы увидели, с помощью этого инструмента мы можем обработать файлы, отвечающие определенным требованиям: с определенным именем, размером, правами на файл и пр.