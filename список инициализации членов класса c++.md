Мы можем инициализировать члены нашего класса в конструкторе через оператор присваивания:

```cpp
class Values
{
private:
    int m_value1;
    double m_value2;
    char m_value3;
public:
    Values()
    {
        // Это всё операции присваивания, а не инициализация
        m_value1 = 3;
        m_value2 = 4.5;
        m_value3 = 'd';
    }
};
```

==Сначала создаются== `m_value1`, `m_value2` и `m_value3`. ==Затем выполняется тело конструктора, где этим переменным присваиваются значения==. Аналогичен код в не объектно-ориентированном C++:

```cpp
int m_value1;
double m_value2;
char m_value3;
m_value1 = 3;
m_value2 = 4.5;
m_value3 = 'd';
```

Хотя в плане синтаксиса языка C++ вопросов никаких нет — всё корректно, но более эффективно — использовать инициализацию, а не присваивание после объявления.

Некоторые типы данных (например, константы и ссылки) должны быть инициализированы сразу. Рассмотрим следующий пример:

```cpp
class Values
{
private:
    const int m_value;
public:
    Values()
    {
        m_value = 3; // ошибка: константам нельзя присваивать значения
    }
};
```

Аналогичен код в не объектно-ориентированном C++:

```cpp
const int m_value; // ошибка: константы должны быть инициализированы значениями 

m_value = 7; // ошибка: константам нельзя присваивать значения
```

Для решения этой проблемы в C++ добавили метод инициализации переменных-членов класса через **список инициализации членов**, вместо присваивания им значений после объявления. Не путайте этот список с аналогичным списком инициализаторов, который используется для инициализации массивов.

Использование списка инициализации почти идентично выполнению прямой инициализации (или uniform-инициализации в C++11).

Список инициализации членов находится сразу же после параметров конструктора. Он начинается с двоеточия (`:`), а затем значение для каждой переменной указывается в круглых скобках. Больше не нужно выполнять операции присваивания в теле конструктора. Также обратите внимание, что список инициализации членов не заканчивается точкой с запятой:

```cpp
#include <iostream>
class Values
{
private:
    int m_value1;
    double m_value2;
    char m_value3;
public:
    Values(int value1, double value2, char value3='d')
        : m_value1(value1), m_value2(value2), m_value3(value3) // напрямую инициализируем переменные-члены класса
    {
    // Нет необходимости использовать присваивание
    }
    void print()
    {
         std::cout << "Values(" << m_value1 << ", " << m_value2 << ", " << m_value3 << ")\n";
    }
};

int main()
{
    Values value(3, 4.5); // value1 = 3, value2 = 4.5, value3 = 'd' (значение по умолчанию)
    value.print();
    return 0;
}
```

Мы можем использовать параметры по умолчаниюдля предоставления значений по умолчанию, если пользователь их не предоставил. Например, класс, который имеет константную переменную-член:

```cpp
class Values
{
private:
    const int m_value;
public:
    Values(): m_value(7) // напрямую инициализируем константную переменную-член
    {
    
    }
};
```

Это работает, поскольку нам разрешено инициализировать константные переменные (но не присваивать им значения после объявления!).

==Правило: Используйте списки инициализации членов, вместо операций присваивания, для инициализации переменных-членов вашего класса.==

## uniform-инициализация в C++11

В C++11 вместо прямой инициализации можно использовать uniform-инициализацию:

```cpp
class Values
{
private:
    const int m_value;
public:
    Values(): m_value { 7 } // используем uniform-инициализацию
    {

    }
};
```

Настоятельно рекомендуется использовать этот синтаксис (даже если вы не используете константы или ссылки в качестве переменных-членов вашего класса), поскольку списки инициализации членов необходимы при композиции и наследовании (это рассмотрим несколько позже).

==Правило: Используйте uniform-инициализацию вместо прямой инициализации в C++11.==

## Инициализация переменных-членов, которые являются классами

Список инициализации членов также может использоваться для инициализации членов, которые являются классами:

```cpp
#include <iostream>

class A
{
public:
    A(int a) { std::cout << "A " << a << "\n"; }
};

class B
{
private:
    A m_a;
public:
    B(int b)
         : m_a(b-1) // вызывается конструктор A(int) для инициализации члена m_a
    {
        std::cout << "B " << b << "\n";
    }
};

int main()

{
    B b(7);
    return 0;
}
```

При создании переменной `b` вызывается конструктор `B(int)` со значением `7`. До того, как тело конструктора выполнится, инициализируется `m_a`, вызывая конструктор `A(int)` со значением `6`. Таким образом, выведется `A 6`. Затем управление возвратится обратно к конструктору B(), и тогда уже он выполнится и выведется `B 7`.

## Использование списков инициализации

Если список инициализации помещается на той же строке, что и имя конструктора, то лучше всё разместить в одной строке:

```cpp
class Values
{
private:
    int m_value1;
    double m_value2;
    char m_value3;
public:
    Values() : m_value1(3), m_value2(4.5), m_value3('d') // всё находится в одной строке
    {

    }
};
```

Если список инициализации членов не помещается в строке с именем конструктора, то на следующей строке (используя перенос) инициализаторы должны быть с отступом:

```cpp
class Values
{
private:
    int m_value1;
    double m_value2;
    char m_value3;
public:
    Values(int value1, double value2, char value3='d') // на этой строке уже и так много чего,
        : m_value1(value1), m_value2(value2), m_value3(value3) // поэтому переносим инициализаторы на новую строку (не забываем использовать отступ)
    {

    }
};
```

Если все инициализаторы не помещаются на одной строке, то вы можете выделить для каждого инициализатора отдельную строку:

```cpp
class Values
{
private:
    int m_value1;
    double m_value2;
    char m_value3;
    float m_value4;
public:
    Values(int value1, double value2, char value3='d', float value4=17.5) // на этой строке уже и так много чего,
        : m_value1(value1), // поэтому выделяем каждому инициализатору отдельную строку, не забывая о запятой в конце
        m_value2(value2),
        m_value3(value3),
        m_value4(value4)
    {

    }
};
```

## Порядок выполнения в списке инициализации

Удивительно, но переменные в списке инициализации не инициализируются в том порядке, в котором они указаны. Вместо этого они инициализируются в том порядке, в котором объявлены в классе, поэтому следует соблюдать следующие рекомендации:

   - Не инициализируйте переменные-члены таким образом, чтобы они зависели от других переменных-членов, которые инициализируются первыми (другими словами, убедитесь, что все ваши переменные-члены правильно инициализируются, даже если порядок в списке инициализации отличается).

   - Инициализируйте переменные в списке инициализации в том порядке, в котором они объявлены в классе.