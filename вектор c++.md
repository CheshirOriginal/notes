В стандартной библиотеке C++ _вектором_ ([std::vector](https://en.cppreference.com/w/cpp/container/vector)) называется динамический массив, обеспечивающий быстрое добавление новых элементов в конец и меняющий свой размер при необходимости. Вектор гарантирует отсутствие утечек памяти (об этом мы поговорим в других параграфах, сейчас просто считайте, что это хорошо).

Для работы с вектором нужно подключить заголовочный файл `vector`.

Элементы вектора должны быть одинакового типа, и этот тип должен быть известен при компиляции программы. Он задаётся в угловых скобках после `std::vector`: например, `std::vector<int>` — это вектор целых чисел типа `int`, а `std::vector<std::string>` — вектор строк.

Само имя `std::vector` не является типом данных: это _шаблон_, в который требуется подставить нужные параметры (тип элемента), чтобы получился конкретный тип данных.

### Инициализация вектора

```c++
#include <string>
#include <vector>

int main() {
	// пустой вектор строк
    std::vector<std::string> v1;
    // вектор из пяти пустых строк
    std::vector<std::string> v2(5);  
    // вектор из пяти строк "hello"
    std::vector<std::string> v3(5, "hello"); 
    // инициализируем вектор через список инициализации,
    // в котором элементы перечислены через запятую.
    std::vector<int> data = {1, 2, 3, 4, 5}; 
    
}
```

### Обращение к элементам

Вектор хранит элементы в памяти последовательно, поэтому ==по индексу элемента можно быстро найти его положение в памяти==. Индексация начинается с нуля:

```c++
std::vector<int> data = {1, 2, 3, 4, 5};
int a = data[0];  // начальный элемент вектора
int b = data[4];  // последний элемент вектора (в нём пять элементов)
data[2] = -3;  // меняем элемент 3 на -3
```

==Чтобы узнать общее количество элементов в векторе, можно воспользоваться функцией `size`==:

```c++
std::cout << data.size() << "\n";
```

==Отрицательные индексы, как в некоторых других языках программирования, не допускаются.==

Обратите внимание: ==когда мы обращаемся по индексу через квадратные скобки, проверки его корректности не происходит.== Это ещё одно проявление принципа _«мы не должны платить за то, что не используем»_.

Если всё же обратиться к вектору по некорректному индексу, то программа во время выполнения попадёт в неопределённое поведение: фактически она попробует прочитать память, не принадлежащую вектору.

==Если вам не хочется делать много лишних проверок, а в корректности индекса вы не уверены, то можно использовать функцию `at`==:

```c++
std::vector<int> data = {1, 2, 3, 4, 5};
std::cout << data[42] << "\n";  // неопределённое поведение: может произойти всё что угодно
std::cout << data.at(0) << "\n";  // напечатается 1
std::cout << data.at(42) << "\n";  // произойдёт исключение std::out_of_range — его можно будет перехватить и обработать
```

Рассмотрим ==функции вектора `front` и `back`, которые возвращают его первый и последний элемент без использования индексов==:

```c++
std::vector<int> data = {1, 2, 3, 4, 5};
std::cout << data.front() << "\n";  // то же, что data[0]
std::cout << data.back() << "\n";  // то же, что data[data.size() - 1]
```

==Важно учитывать, что вызов этих функций на пустом векторе приведёт к неопределённому поведению.==

==Для проверки вектора на пустоту== вместо сравнения `data.size() == 0` ==принято использовать функцию `empty`==, которая возвращает логическое значение:

```c++
if (!data.empty()) {
   // вектор не пуст, с ним можно работать
}
```
### Добавление и удаление элементов

==В вектор можно эффективно добавлять элементы в конец и удалять их с конца.== Для этого существуют функции `push_back` и `pop_back`. Рассмотрим программу, считывающую числа с клавиатуры в вектор и затем удаляющую все нули в конце:

```c++
#include <iostream>
#include <vector>

int main() {
    int x;
    std::vector<int> data;
    while (std::cin >> x) {  // читаем числа, пока не закончится ввод
        data.push_back(x);  // добавляем очередное число в вектор
    }

    while (!data.empty() && data.back() == 0) {
        // Пока вектор не пуст и последний элемент равен нулю
        data.pop_back();  // удаляем этот нулевой элемент
    }
}
```

==Добавление элементов в другие части вектора или их удаление неэффективно, так как требует сдвига соседних элементов.== Поэтому отдельных функций, например, для добавления или удаления элементов из начала у вектора нет. Это можно сделать с помощью общих функций `insert`/`erase` и итераторов.

==Удалить все элементы из вектора можно с помощью функции `clear`.==
### Резерв памяти

Вектор хранит элементы в памяти в виде непрерывной последовательности, друг за другом. При этом в конце последовательности резервируется дополнительное место для быстрого добавления новых элементов. Когда этот резерв заканчивается, при вставке очередного элемента происходит _реаллокация_: элементы вектора копируются в новый, более просторный блок памяти.

Реаллокация — довольно дорогая процедура, но если она происходит достаточно редко, то её влияние незначительно. Можно доказать, что если размер нового блока выбирать в два раза больше предыдущего размера, то [амортизационная сложность](https://en.wikipedia.org/wiki/Amortized_analysis) добавления элемента будет константной.

==Текущий резерв вектора можно узнать с помощью функции== `capacity`.

Иногда требуется заполнить вектор элементами, причём число элементов известно заранее. В таком случае ==можно сразу зарезервировать нужный размер памяти с помощью функции== `reserve`, чтобы при добавлении элементов не происходили реаллокации. Пусть, например, нам сначала задаётся число слов, а потом сами эти слова, и нам требуется сложить их в вектор:

```c++
#include <iostream>
#include <string>
#include <vector>

int main() {
    std::vector<std::string> words;

    size_t words_count;
    std::cin >> words_count;

    // Размер вектора остаётся нулевым, меняется только резерв:
    words.reserve(words_count);

    for (size_t i = 0; i != words_count; ++i) {
        std::string word;
        std::cin >> word;
        // Все добавления будут дешёвыми, без реаллокаций:
        words.push_back(word);
    }
}
```

==Если передать в `reserve` величину меньше текущего резерва, то ничего не поменяется — резерв останется прежним.==

Функцию `reserve` не следует путать с функцией ==`resize`, которая меняет количество элементов в векторе.== Если аргумент функции `resize` меньше текущего размера, то лишние элементы в конце вектора удаляются. Если же он больше текущего размера, то при необходимости происходит реаллокация и в вектор добавляются новые элементы с дефолтным значением данного типа.

```c++
#include <vector>

int main() {
    std::vector<int> data = {1, 2, 3, 4, 5};

    data.reserve(10);  // поменяли резерв, но размер вектора остался равным пяти

    data.resize(3);  // удалили последние элементы 4 и 5
    data.resize(6);  // получили вектор 1, 2, 3, 0, 0, 0
}
```

## Многомерные векторы

Воспользуемся вектором векторов, чтобы сохранить матрицу (таблицу) целых чисел. Пусть на вход программы сначала поступают число строк и число столбцов матрицы, а потом — сами элементы построчно:

```c++
#include <iostream>
#include <vector>

int main() {
    size_t m, n;
    std::cin >> m >> n;  // число строк и столбцов

    // создаём матрицу matrix из m строк, каждая из которых — вектор из n нулей
    std::vector<std::vector<int>> matrix(m, std::vector<int>(n));

    for (size_t i = 0; i != m; ++i) {
        for (size_t j = 0; j != n; ++j) {
            std::cin >> matrix[i][j];
        }
    }

    // напечатаем матрицу, выводя элементы через табуляцию
    for (size_t i = 0; i != m; ++i) {
        for (size_t j = 0; j != n; ++j) {
            std::cout << matrix[i][j] << "\t";
        }
        std::cout << "\n";
    }
}
```

В этом примере мы заранее создали матрицу из нулей, а потом просто меняли её элементы.
## Сортировка вектора

Рассмотрим типичную задачу — ==отсортировать вектор по возрастанию==. Для этого в стандартной библиотеке в заголовочном файле `algorithm` есть готовая функция [`sort`](https://en.cppreference.com/w/cpp/algorithm/sort). Гарантируется, что сложность её работы в худшем случае составляет O(nlog⁡n), где n — число элементов в векторе. Типичные реализации используют алгоритм сортировки [Introsort](https://en.wikipedia.org/wiki/Introsort).

```c++
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> data = {3, 1, 4, 1, 5, 9, 2, 6};

    // Сортировка диапазона вектора от начала до конца
    std::sort(data.begin(), data.end());

    // получим вектор 1, 1, 2, 3, 4, 5, 6, 9
}
```

В функцию `sort` передаются _итераторы_, ограничивающие рассматриваемый диапазон. В нашем случае мы передаём диапазон, совпадающий со всем вектором, от начала до конца. Соответствующие итераторы возвращают функции `begin` и `end` (не путать с `front` и `back`!).

==Для сортировки по убыванию можно передать на вход _обратные итераторы==_ `rbegin()` и `rend()`, представляющие элементы вектора в перевёрнутом порядке:

```c++
std::sort(data.rbegin(), data.rend());  // 9, 6, 5, 4, 3, 2, 1, 1
```

В C++20 доступен более элегантный способ сортировки через `std::ranges::sort`:

```c++
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> data = {3, 1, 4, 1, 5, 9, 2, 6};

    std::ranges::sort(data);  // можно передать сам вектор, а не его диапазоны
}
```

Для сортировки по умолчанию используется сравнение элементов с помощью оператора `<`. Этот оператор работает и для самих векторов: они сравниваются [лексикографически](https://en.wikipedia.org/wiki/Lexicographic_order). Поэтому можно без проблем отсортировать, например, строки в матрице (векторе векторов целых чисел).