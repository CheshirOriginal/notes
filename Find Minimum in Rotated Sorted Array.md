https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/
### Условие

Предположим, что массив длины `n`, отсортированный по возрастанию, **циклически сдвигается** от `1`и до `n`раз. Например, массив `nums = [0,1,2,4,5,6,7]`может принять следующий вид:

- `[4,5,6,7,0,1,2]`если бы он был повернут `4`раз.
- `[0,1,2,4,5,6,7]`если бы он был повернут `7`раз.

Обратите внимание, что **поворот** массива `[a[0], a[1], a[2], ..., a[n-1]]`1 раз приводит к получению массива `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Учитывая отсортированный повернутый массив `nums`уникальных **элементов** , вернуть _минимальный элемент этого массива_ .

Вам необходимо написать алгоритм, работающий в  `O(log n) time`.
### Пример
**Ввод:** nums = [3,4,5,1,2]
**Выход:** 1

**Ввод:** nums = [4,5,6,7,0,1,2]
**Выход:** 0
### Решение

```go
func findMin(nums []int) int {
    l, r := 0, len(nums)-1
    // проверка на отсортированный массив
    if nums[l] <= nums[r] {
        return nums[l]
    }
	// если нет, то пользуемся бинарным поиском
    for l < r {
        m := l + (r - l) / 2
        if nums[m] > nums[r] {
	        // если средний элемент больше правого, 
	        // значит минимальный элемент находится 
	        // справа от среднего
            l = m + 1
        } else {
	        // в противном случае слева включая средний элемент
            r = m
        }
    }
    return nums[l]
}
```