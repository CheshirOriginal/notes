Скользящее окно - еще один распространенный подход к решению проблем, связанных с массивами. Скользящее окно фактически реализовано с использованием двух указателей! Прежде чем мы начнем, нам нужно поговорить о концепции **подмассива** .
### Подмассивы
Подмассив это непрерывная часть массива. Все элементы должны располагаться рядом друг с другом в исходном массиве и в их первоначальном порядке. Например, с помощью массива `[1, 2, 3, 4]`, подмассивы (сгруппированные по длине) являются:
- Подмассивы длиной 1: `[1]`, `[2]`, `[3]`, `[4]`
- Подмассивы длиной 2: `[1, 2]`, `[2, 3]`, `[3, 4]`
- Подмассивы длиной 3: `[1, 2, 3]`, `[2, 3, 4]`
- Подмассивы длиной 4: `[1, 2, 3, 4]`
**Подмассив может определяться двумя индексами, начальным и конечным** . Например, с помощью `[1, 2, 3, 4]`, подмассив `[2, 3]` имеет начальный индекс `1` и конечный индекс `2`. Давайте назовем начальный индекс **левой границей** , а конечный индекс - **правой границей** . Другое название подмассива в этом контексте - "окно".

![[Pasted image 20250728125106.png]]

### "Допустимые" подмассивы
Общий шаблон, который вы увидите в задачах с массивами, включает идею "допустимого" подмассива. Описание задачи явно или неявно определяет, что делает подмассив "допустимым". Мы можем разделить его на две части:

1. Метрика ограничения. Это атрибут подмассива. - Например, сумма подмассива, количество уникальных элементов в подмассиве, частота определенного элемента и т.д.
2. Числовое ограничение на метрику ограничения.

Например, предположим, что проблема объявляет подмассив допустимым, если его сумма меньше или равна `10`. Метрикой ограничения здесь является сумма подмассива, а числовым ограничением является `<= 10`. Подмассив считается допустимым, если его ограничивающая метрика соответствует числовому ограничению, т.е. Сумма меньше или равна `10`.
### Идея
Скользящее окно используется для анализа и поиска допустимых подмассивов массива. Идея скользящего окна заключается в поддержании двух переменных, `left` и `right` В любой момент времени, `left` представляет левую границу нашего окна, и `right` представляет правую границу нашего окна. Помните, что "окно" здесь - это другое слово, обозначающее подмассив.

Первоначально мы устанавливаем `left = right = 0`, что означает, что первое окно, которое мы рассматриваем, само по себе является всего лишь первым элементом массива. Мы хотим увеличить размер нашего "окна", и мы делаем это путем увеличения `right`. Когда мы увеличиваем `right`, это похоже на "добавление" нового элемента в наше окно.

Но что, если после добавления нового элемента подмассив становится недействительным? Например, предположим, что добавление нового элемента справа делает сумму подмассива слишком большой. Нам нужно "удалить" некоторые элементы из нашего окна, пока оно снова не станет действительным. Чтобы "удалить" элементы, мы можем увеличить `left`, который уменьшает наше окно.

> Запомни: `left` и `right` представляют границы нашего окна в любой момент времени, поэтому увеличивающийся `left` это эквивалентно удалению самого левого элемента.

Добавляя и удаляя элементы, мы "сдвигаем" наше окно вдоль входных данных. Размер окна постоянно меняется - оно увеличивается настолько, насколько это возможно, пока не станет недействительным, а затем сжимается до тех пор, пока снова не станет действительным. Однако он всегда скользит вправо, пока не достигнет конца ввода.
### Реализация
Теперь, когда у вас есть представление о том, как работает скользящее окно, давайте поговорим о том, как это реализовать. Для этого раздела мы будем использовать предыдущий пример (найдите самый длинный подмассив с суммой, меньшей или равной `k`).

Во-первых, нам нужно определить **метрику ограничения** . В нашем примере метрикой ограничения является сумма окон. Как нам отслеживать сумму окна по мере добавления и удаления элементов? Один из способов, которым мы могли бы это сделать, - сохранить окно в отдельном массиве. Когда мы добавляем элементы справа, мы добавляем их в наш массив. Когда мы удаляем элементы слева, мы удаляем соответствующие элементы из массива. Таким образом, мы всегда можем найти сумму нашего текущего окна, просто суммируя элементы в отдельном массиве.

Это очень неэффективно, так как удаление элементов и нахождение суммы окна будет O(n) O (n) операций. Как мы можем улучшить работу?

На самом деле нам не нужно хранить окно в отдельном массиве. Все, что нам нужно, это некоторая переменная, давайте назовем ее `curr`, который отслеживает текущую сумму. Когда мы добавляем новый элемент справа, мы просто делаем `curr += nums[right]`. Когда мы удаляем элемент слева, мы просто делаем `curr -= nums[left]`. Таким образом, все операции выполняются в O(1).

> Обратите внимание, что наше окно существует только как идея. Мы не поддерживаем его в буквальном смысле с помощью массива. Нам нужно только `left` и `right` помнить о его границах, и `curr` чтобы отслеживать метрику ограничения.

Далее, как нам переместить указатели `left` и `right`? Помните, мы хотим продолжать расширять наше окно, и оно всегда сдвигается вправо - просто по пути оно может несколько раз уменьшиться . Потому что `right` всегда движется вперед, мы можем использовать цикл for для повторения `right` поверх входных данных. На каждой итерации цикла for мы будем добавлять элемент `nums[right]` к нашему окну.

Что насчет `left`? Когда мы сдвигаем `left`, мы уменьшаем наше окно. Мы уменьшаем его только тогда, когда оно становится недействительным. Поддерживая `curr`, мы можем легко определить, является ли текущее окно допустимым, просто проверив его значение. Если `curr > k`, окно недействительно.

Допустим, `nums = [1, 1, 1, 3]` и `k = 3`. Когда мы прибудем в `3` и добавьте его в окно, окно станет недействительным, и `curr` будет равно `6`. Нам нужно удалить три элемента слева, прежде чем окно снова станет действительным.

Это говорит о том, что мы должны использовать цикл while для выполнения удалений. Условием будет `while curr > k` ("пока окно недействительно"). Чтобы выполнить удаления, мы делаем `curr -= nums[left]` а затем увеличивайте `left` в каждой итерации цикла while.

Теперь у нас есть систематический способ перемещать наше окно по входным данным, сохраняя его достоверность. Как нам обновить ответ? На каждой итерации цикла for, после цикла while, мы знаем, что текущее окно допустимо. Мы можем написать здесь код для обновления ответа. Формула для длины окна равна `right - left + 1` (==запомните эту формулу==).

Вот некоторый псевдокод, который объединяет все это воедино:

```
function fn(nums, k):
    left = 0
    curr = 0
    answer = 0
    for (int right = 0; right < nums.length; right++):
        curr += nums[right]
        while (curr > k):
            curr -= nums[left]
            left++

        answer = max(answer, right - left + 1)

    return answer
```

Вот псевдокод для общего шаблона:

```
function fn(arr):
    left = 0
    for (int right = 0; right < arr.length; right++):
        //Выполните некоторые логические действия, чтобы «добавить» 
        //элемент в arr[right] к окну

        while WINDOW_IS_INVALID:
            //Выполните некоторые логические действия, чтобы «удалить» 
            //элемент arr[left] из окна
            left++

         //Примените логику, чтобы обновить ответ.
```

### Почему раздвижное окно эффективно?

Скользящее окно гарантирует максимум 2n итераций окна - правый указатель может перемещаться n раз и левый указатель может двигаться n раз. Это означает, что если логика, выполняемая для каждого окна, O(1) , алгоритмы скользящего окна работают в O(n).

### Пример
> Вам дана двоичная строка `s`(строка, содержащая только `"0"` и `"1"`). Вы можете выбрать до одного `"0"`и переверните его в `"1"`Какова длина наибольшей подстроки, которая может содержать только `"1"`?
> 
> Например, дано `s = "1101100111"`, ответ таков `5`. Если вы выполните переворот в индексе `2`, строка становится `1111100111`.

Поскольку строка может содержать только `"1"` и `"0"`, ==другой способ взглянуть на эту проблему так: «какова самая длинная подстрока, которая содержит **не более одного символа?»** `"0"`?".== Это позволяет нам легко решить задачу с помощью скользящего окна, где наше условие `window.count("0") <= 1`. Мы можем использовать целое число `curr`который отслеживает, сколько `"0"`в настоящее время мы имеем в нашем окне.

```c++
int findLength(string s) {
    // curr is the current number of zeros in the window
    int left = 0, curr = 0, ans = 0;
    for (int right = 0; right < s.size(); right++) {
        if (s[right] == '0') {
            curr++;
        }
        
        while (curr > 1) {
            if (s[left] == '0') {
                curr--;
            }
            left++;
        }
        
        ans = max(ans, right - left + 1);
    }
    
    return ans;
}
```

### Количество подмассивов
Если задача требует вычисления **количества подмассивов** , соответствующих некоторому ограничению, мы все равно можем использовать скользящее окно, но нам нужно будет применить аккуратный математический трюк для вычисления количества подмассивов.

==Предположим, что мы используем алгоритм скользящего окна, который мы изучили, и в настоящее время имеем окно `(left, right)`. Сколько допустимых окон **заканчиваются** на индексе `right`?==

Вот текущее окно `(left, right)`, затем `(left + 1, right)`, `(left + 2, right)`, и так далее до тех пор, пока `(right, right)`(только элемент в `right`).

Вы можете зафиксировать правую границу, а затем выбрать любое значение между `left` и `right`Включая левую границу. ==Следовательно, количество допустимых окон, **заканчивающихся** индексом `right`равен размеру окна, которое, как мы знаем, `right - left + 1`.==

> Произведение подмассива меньше K.
> 
> Дан массив положительных целых чисел `nums`и целое число `k`, возвращает количество подмассивов, где произведение всех элементов подмассива строго меньше `k`.
> 
> Например, учитывая входные данные `nums = [10, 5, 2, 6], k = 100`, ответ таков `8`. Подмассивы с произведениями меньше `k` являются:
> 
> `[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]`

Чтобы продемонстрировать только что изученное свойство, давайте рассмотрим пример из описания. Когда мы достигаем индекса `2`, то произведение становится слишком большим, поэтому нам нужно удалить самый левый элемент `10`. Теперь окно действительно и имеет длину `2`. Это означает, что есть `2`допустимые подмассивы, которые заканчиваются здесь ( `[2]` и `[5, 2]`).

Напомним, что в предыдущих примерах мы обновляли ответ (максимальную длину) после цикла while, когда окно должно быть допустимым. Здесь мы можем добавить к ответу текущий размер окна. Ограничение, определяющее допустимость окна, заключается в том, что произведение должно быть меньше `k`.

Кроме того, обратите внимание, что если `k <= 1`у нас никогда не может быть никаких действительных окон, поэтому мы можем просто вернуться `0` немедленно.

```c++
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        if (k <= 1) {
            return 0;
        }

        int ans = 0, left = 0, curr = 1;
        for (int right = 0; right < nums.size(); right++) {
            curr *= nums[right];
            while (curr >= k) {
                curr /= nums[left];
                left++;
            }
            
            ans += right - left + 1;
        }
        
        return ans;
    }
};
```
### Фиксированный размер окна
В рассмотренных выше примерах размер окна был динамическим. Мы старались максимально расширить его вправо, сохраняя при этом определённые ограничения, и удаляли элементы слева, когда эти ограничения нарушались. Иногда задача требует **фиксированной** длины. `k`.

Эти проблемы просты, поскольку разница между любыми двумя соседними окнами составляет всего два элемента (мы добавляем один элемент справа и удаляем один элемент слева, чтобы сохранить длину).

Начните с построения первого окна (из индекса `0` к `k - 1`). Как только у нас появится окно размером `k`, если мы добавим элемент по индексу `i`, нам нужно удалить элемент по индексу `i - k`. Например, `k = 2`и в настоящее время у вас есть элементы с индексами `[0, 1]`. Теперь мы добавляем `2`: `[0, 1, 2]`. Чтобы сохранить размер окна на уровне `k = 2`, нам нужно удалить `2 - k = 0`: `[1, 2]`.

Вот псевдокод:

```
function fn(arr, k):
    curr = some data to track the window

    // построить первое окно
    for (int i = 0; i < k; i++)
        //Сделайте что-нибудь с curr или другими переменными, чтобы 
        //построить первое окно

    ans = переменная ответа, вероятно, равная curr здесь в зависимости от задачи
    for (int i = k; i < arr.length; i++)
        Добавить arr[i] в окно
        Удалить arr[i - k] из окна
        Обновить ответ

    return ans
```

> Пример: Дан массив целых чисел. `nums` и целое число `k`, найдите сумму подмассива с наибольшей суммой, длина которого равна `k`.

Как мы уже упоминали, мы можем построить окно длиной `k`и затем перемещайте его вдоль массива. Добавляйте и удаляйте по одному элементу за раз, чтобы окно сохраняло свой размер. `k`. Если мы добавляем значение в `i`, то нам нужно удалить значение в `i - k`.

```c++
int findBestSubarray(vector<int>& nums, int k) {
    int curr = 0;
    for (int i = 0; i < k; i++) {
        curr += nums[i];
    }
    
    int ans = curr;
    for (int i = k; i < nums.size(); i++) {
        curr += nums[i] - nums[i - k];
        ans = max(ans, curr);
    }
    
    return ans;
}
```