
https://leetcode.com/explore/learn/card/linked-list/214/two-pointer-technique/1212/
### Условие
Из связанного списка верните _узел, с которого начинается цикл. Если цикла нет, верните_ `null`.
### Решение

```go
func detectCycle(head *ListNode) *ListNode {
    if head == nil {
        return nil
    }
    set := make(map[*ListNode]bool)
    tmp := head
    for tmp.Next != nil {
        if set[tmp] {
            return tmp
        }
        set[tmp] = true
        tmp = tmp.Next
    }
    return nil
} 
```

### Принцип 

Можно использовать хэш-таблицу (моделируем set). Проходимся по списку, запоминаем указатель на текущую запись, если указатель повторяется (уже есть в таблице) то в списке есть цикл и возвращаем указатель как начало этого цикла.

Еще можно через 2 указателя. Запускаем указатели с быстрым и медленным шагом. Если они соприкоснулись, значит есть цикл, прекращаем шаги. 
После этого запускаем указать с начала списка со скоростью медленного и медленный с той же скоростью с позиции последней остановки. Элемент, на котором они сойдутся, будет началом цикла. 
Решения хорошее, но я не до конца понимаю, почему оно работает. 

