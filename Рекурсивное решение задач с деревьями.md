Обычно мы можем решить задачу с деревом рекурсивно, используя подход «сверху вниз» или «снизу вверх».

### Решение «сверху вниз»

«Сверху вниз» означает, что в каждом рекурсивном вызове мы сначала обращаемся к узлу, чтобы получить некоторые значения, и передаем эти значения его дочерним узлам при рекурсивном вызове функции. Таким образом, решение «сверху вниз» можно рассматривать как своего рода **обход в прямом порядке** . Конкретно, рекурсивная функция `top_down(root, params)`работает так:

```
1. return specific value for null node
2. update the answer if needed                      // answer <-- params
3. left_ans = top_down(root.left, left_params)      // left_params <-- root.val, params
4. right_ans = top_down(root.right, right_params)   // right_params <-- root.val, params
5. return the answer if needed                      // answer <-- left_ans, right_ans
```

Например, рассмотрим такую ​​задачу: дано бинарное дерево, найти его максимальную глубину.

Здесь мы определим глубину корневого узла как 1 (хотя часто глубина корневого узла определяется как 0). Для каждого узла, если мы знаем его глубину, мы будем знать глубину его дочерних узлов. Таким образом, если мы передадим глубину узла в качестве параметра при рекурсивном вызове функции, все узлы будут знать свою глубину. Для листовых узлов мы можем использовать глубину для обновления окончательного ответа. Вот псевдокод рекурсивной функции. `maximum_depth(root, depth)`:

```
1. return if root is null
2. if root is a leaf node:
3.     answer = max(answer, depth)         // update the answer if needed
4. maximum_depth(root.left, depth + 1)     // call the function recursively for left child
5. maximum_depth(root.right, depth + 1)    // call the function recursively for right child
```

```c++
int answer; // не забудьте инициализировать answer перед вызовом maximum_thought
void maximum_depth(TreeNode* root, int depth) {
    if (!root) {
        return;
    }
    if (!root->left && !root->right) {
        answer = max(answer, depth);
    }
    maximum_depth(root->left, depth + 1);
    maximum_depth(root->right, depth + 1);
}
```

### Решение «снизу вверх»

«Снизу вверх» — ещё одно рекурсивное решение. В каждом рекурсивном вызове мы сначала вызываем функцию рекурсивно для всех дочерних узлов, а затем получаем ответ на основе возвращаемых значений и значения текущего узла. Этот процесс можно рассматривать как своего рода **обратный** обход. Обычно рекурсивная функция «снизу вверх» `bottom_up(root)`будет что-то вроде этого:

```
1. return specific value for null node
2. left_ans = bottom_up(root.left)      // call function recursively for left child
3. right_ans = bottom_up(root.right)    // call function recursively for right child
4. return answers                       // answer <-- left_ans, right_ans, root.val
```
 
Давайте продолжим обсуждение вопроса о максимальной глубине, но используя другой способ мышления: для одного узла дерева, какова будет максимальная глубина? `x`поддерева, корнем которого является он сам?

Если мы знаем максимальную глубину `l`поддерева, корнем которого является его **левый** потомок, и максимальная глубина `r`поддерева, корнем которого является его **правый** дочерний узел, можем ли мы ответить на предыдущий вопрос? Конечно, да, мы можем выбрать максимальное значение из них и прибавить 1, чтобы получить максимальную глубину поддерева, корнем которого является текущий узел. То есть `x = max(l, r) + 1`.

Это означает, что для каждого узла мы можем получить ответ, решив задачу для его дочерних узлов. Следовательно, мы можем решить эту задачу, используя решение «снизу вверх». Вот псевдокод рекурсивной функции. `maximum_depth(root)`:

```
1. return 0 if root is null                 // return 0 for null node
2. left_depth = maximum_depth(root.left)
3. right_depth = maximum_depth(root.right)
4. return max(left_depth, right_depth) + 1  // return depth of the subtree rooted at root
```

```c++
int maximum_depth(TreeNode* root) {
    if (!root) {
        return 0; // return 0 for null node
    }
    int left_depth = maximum_depth(root->left);
    int right_depth = maximum_depth(root->right);
    return max(left_depth, right_depth) + 1; // return depth of the subtree rooted at root
}
```