**Виртуальная функция в языке С++** — это особый тип функции, которая, при её вызове, выполняет «наиболее» дочерний метод, который существует между родительским и дочерними классами. Это свойство еще известно, как **полиморфизм**. Дочерний метод вызывается тогда, когда совпадает сигнатура (имя, типы параметров и является ли метод константным) и тип возврата дочернего метода с сигнатурой и типом возврата метода родительского класса. Такие методы называются **переопределениями** (или _**«переопределенными методами»**_).

Чтобы сделать функцию виртуальной, нужно просто указать **ключевое слово `virtual`** перед объявлением функции. Например:

```cpp
#include <iostream>

class Parent
{
public:
    virtual const char* getName() { return "Parent"; } // добавили ключевое слово virtual
};

class Child: public Parent
{
public:
    virtual const char* getName() { return "Child"; }
};

int main()
{
    Child child;
    Parent &rParent = child;
    std::cout << "rParent is a " << rParent.getName() << '\n';
    return 0;
}

// rParent is a Child
```

Поскольку `rParent` является ссылкой на родительскую часть объекта `child`, то, обычно, при обработке `rParent.getName()` вызывался бы Parent::getName(). Тем не менее, поскольку Parent::getName() является виртуальной функцией, то компилятор понимает, что нужно посмотреть, есть ли переопределения этого метода в дочерних классах. И компилятор находит Child::getName()!

```cpp
#include <iostream>

class A
{
public:
    virtual const char* getName() { return "A"; }
};

class B: public A
{
public:
    virtual const char* getName() { return "B"; }
};

class C: public B
{
public:
    virtual const char* getName() { return "C"; }
};

class D: public C
{
public:
    virtual const char* getName() { return "D"; }
};

int main()
{
    C c;
    A &rParent = c;
    std::cout << "rParent is a " << rParent.getName() << '\n';
    return 0;
}

// rParent is a C
```

Как вы думаете, какой результат выполнения этой программы?

Рассмотрим всё по порядку:

   Сначала создается объект `c` класса C.

   - `rParent` — это ссылка класса A, которой мы указываем ссылаться на часть A объекта `c`.

   - Затем вызывается метод `rParent.getName()`.

   - Вызов `rParent.GetName()` приводит к вызову A::getName(). Однако, поскольку A::getName() является виртуальной функцией, то компилятор ищет «наиболее» дочерний метод между A и C. В этом случае — это C::getName().

Обратите внимание, компилятор не будет вызывать D::getName(), поскольку наш исходный объект был класса C, а не класса D, поэтому рассматриваются методы только между классами A и C.

==**_Предупреждение_:** Сигнатура виртуального метода дочернего класса должна _полностью_ соответствовать сигнатуре виртуального метода родительского класса. Если у дочернего метода будет другой тип параметров, нежели у родительского, то вызываться этот метод не будет.==

## Использование ключевого слова virtual

Если функция отмечена как виртуальная, то все соответствующие переопределения тоже считаются виртуальными, даже если возле них явно не указано ключевое слова virtual. Однако, наличие ключевого слова virtual возле методов дочерних классов послужит полезным напоминанием о том, что эти методы являются виртуальными, а не обычными. Следовательно, полезно указывать ключевое слово virtual возле переопределений в дочерних классах, даже если это не является строго необходимым.

## Использование модификатора override

Модификатор override может использоваться с любым методом, который должен быть переопределением. Достаточно просто указать override в том месте, где обычно указывается const (после скобок с параметрами). Если метод не переопределяет виртуальную функцию родительского класса, то компилятор выдаст ошибку:

```cpp
#include <iostream>

class A
{
public:
virtual const char* getName1(int x) { return "A"; }
virtual const char* getName2(int x) { return "A"; }
virtual const char* getName3(int x) { return "A"; }
};

class B : public A
{
public:
virtual const char* getName1(short int x) override { return "B"; }  // ошибка компиляции, метод не является переопределением
virtual const char* getName2(int x) const override { return "B"; }  // ошибка компиляции, метод не является переопределением
virtual const char* getName3(int x) override { return "B"; }  // всё хорошо, метод является переопределением A::getName3(int)
};

int main()
{
return 0;
}
```

Здесь мы получим две ошибки: первая для B::getName1() и вторая для B::getName2(), так как ни один из этих методов не является переопределением виртуальных функций класса А. Метод B::getName3() является переопределением, поэтому с ним никаких проблем нет.

Использование модификатора override никак не влияет на эффективность или производительность программы, но помогает избежать непреднамеренных ошибок. Следовательно, настоятельно рекомендуется использовать модификатор override для каждого из своих переопределений.

==**Правило: Используйте модификатор override для каждого из своих переопределений.**==
## Ковариантный тип возврата

Есть один случай, когда тип возврата переопределения может не совпадать с типом возврата виртуальной функции родительского класса, но при этом оставаться переопределением. Если типом возврата виртуальной функции является указатель или ссылка на класс, то переопределения могут возвращать указатель или ссылку на свой собственный класс (т.е. вместо родительского класса указывать на дочерний класс). Это называется **ковариантным типом возврата**. Например:

```cpp
#include <iostream>

class Parent
{
public:
// Этот метод getThis() возвращает указатель на класс Parent
virtual Parent* getThis() { std::cout << "called Parent::getThis()\n"; return this; }
void printType() { std::cout << "returned a Parent\n"; }
};

class Child : public Parent
{
public:
// Обычно, типы возврата переопределений и виртуальных функций родительского класса должны совпадать.

// Однако, поскольку Child наследует класс Parent, следующий метод может возвращать Child* вместо Parent*
virtual Child* getThis() { std::cout << "called Child::getThis()\n";  return this; }

void printType() { std::cout << "returned a Child\n"; }
};

int main()
{
Child ch;
Parent *p = &ch;
ch.getThis()->printType(); // вызывается Child::getThis(), возвращается Child*, вызывается Child::printType()
p->getThis()->printType(); // вызывается Child::getThis(), возвращается Parent*, вызывается Parent::printType()
}

// called Child::getThis()   
// returned a Child   
// called Child::getThis()   
// returned a Parent

```

Некоторые старые компиляторы могут не поддерживать ковариантные типы возврата.
## Не вызывайте виртуальные функции в теле конструкторов или деструкторов

Вот еще одна ловушка для новичков. Вы не должны вызывать виртуальные функции в теле конструкторовили деструкторов. Почему?

Помните, что при создании объекта класса Child сначала создается родительская часть этого объекта, а затем уже дочерняя? Если вы будете вызывать виртуальную функцию из конструктора класса Parent при том, что дочерняя часть создаваемого объекта еще не была создана, то вызвать дочерний метод вместо родительского будет невозможно, так как объект `child` для работы с методом класса Child еще не будет создан. В таких случаях, в языке C++ будет вызываться родительская версия метода.

Аналогичная проблема существует и с деструкторами. Если вы вызываете виртуальную функцию в теле деструктора класса Parent, то всегда будет вызываться метод класса Parent, так как дочерняя часть объекта уже будет уничтожена.

==**Правило: Никогда не вызывайте виртуальные функции в теле конструкторов или деструкторов.**  ==
## Недостаток виртуальных функций

«Если всё так хорошо с виртуальными функциями, то почему бы не сделать все методы виртуальными?» — спросите Вы. Ответ: «Это неэффективно!». ==Обработка и выполнение вызова виртуального метода занимает больше времени, чем обработка и выполнение вызова обычного метода.== Кроме того, компилятор также должен выделять один дополнительный указатель для каждого объекта класса, который имеет одну или несколько виртуальных функций.