В C++ различают ошибки времени компиляции и ошибки времени выполнения. Ошибки первого типа обнаруживает компилятор до запуска программы. К ним относятся, например, синтаксические ошибки в коде. Ошибки второго типа проявляются при запуске программы. Примеры ошибок времени выполнения: ввод некорректных данных, некорректная работа с памятью, недостаток места на диске и т. д. Часто такие ошибки могут привести к неопределённому поведению программы.

Некоторые ошибки времени выполнения можно обнаружить заранее с помощью проверок в коде. Например, такими могут быть ошибки, нарушающие инвариант класса в конструкторе. Обычно, если ошибка обнаружена, то дальнейшее выполение функции не имеет смысла, и нужно сообщить об ошибке в то место кода, откуда эта функция была вызвана. Для этого предназначен _механизм исключений_.
## Коды возврата и исключения

Рассмотрим функцию, которая считывает со стандартного потока возраст и возвращает его вызывающей стороне. Добавим в функцию проверку корректности возраста: он должен находиться в диапазоне от 0 до 128 лет. Предположим, что повторный ввод возраста в случае ошибки не предусмотрен.

```cpp
int ReadAge() {
    int age;
    std::cin >> age;
    if (age < 0 || age >= 128) {
        // Что вернуть в этом случае?
    }
    return age;
}
```

то вернуть в случае некорректного возраста? Можно было бы, например, договориться, что в этом случае функция возвращает ноль. Но тогда похожая проверка должна быть и в месте вызова функции:

```cpp
int main() {
    if (int age = ReadAge(); age == 0) {
        // Произошла ошибка
    } else {
        // Работаем с возрастом age
    }
}
```

Такая проверка неудобна. Более того, нет никакой гарантии, что в вызывающей функции программист вообще её напишет. Фактически мы тут выбрали некоторое значение функции (ноль), обозначающее ошибку. Это пример подхода к обработке ошибок через _коды возврата_. Другим примером такого подхода является хорошо знакомая нам функция `main`. Только она должна возвращать ноль при успешном завершении и что-либо ненулевое в случае ошибки.

Другим способом сообщить об обнаруженной ошибке являются исключения. С каждым сгенерированным исключением связан некоторый объект, который как-то описывает ошибку. Таким объектом может быть что угодно — даже целое число или строка. Но обычно для описания ошибки заводят специальный класс и генерируют объект этого класса:

```cpp
#include <iostream>

struct WrongAgeException {
    int age;
};

int ReadAge() {
    int age;
    std::cin >> age;
    if (age < 0 || age >= 128) {
        throw WrongAgeException(age);
    }
    return age;
}
```

Здесь в случае ошибки оператор `throw` генерирует исключение, которое представлено временным объектом типа `WrongAgeException`. В этом объекте сохранён для контекста текущий неправильный возраст `age`. Функция досрочно завершает работу: у неё нет возможности обработать эту ошибку, и она должна сообщить о ней наружу. Поток управления возвращается в то место, откуда функция была вызвана. Там исключение может быть перехвачено и обработано.

## Перехват исключения

Мы вызывали нашу функцию `ReadAge` из функции `main`. Обработать ошибку в месте вызова можно с помощью блока `try`/`catch`:

```cpp
int main() {
    try {
        age = ReadAge();  // может сгенерировать исключение
        // Работаем с возрастом age
    } catch (const WrongAgeException& ex) {  // ловим объект исключения
        std::cerr << "Age is not correct: " << ex.age << "\n";
        return 1;  // выходим из функции main с ненулевым кодом возврата
    }
    // ...
}
```

Мы знаем заранее, что функция `ReadAge` может сгенерировать исключение типа `WrongAgeException`. Поэтому мы оборачиваем вызов этой функции в блок `try`. Если происходит исключение, для него подбирается подходящий `catch`-обработчик. Таких обработчиков может быть несколько. Можно смотреть на них как на набор перегруженных функций от одного аргумента — объекта исключения. Выбирается первый подходящий по типу обработчик и выполняется его код. Если же ни один обработчик не подходит по типу, то исключение считается необработанным. В этом случае оно пробрасывается дальше по стеку — туда, откуда была вызвана текущая функция. А если обработчик не найдётся даже в функции `main`, то программа аварийно завершается.

Усложним немного наш пример, чтобы из функции `ReadAge` могли вылетать исключения разных типов. Сейчас мы проверяем только значение возраста, считая, что на вход поступило число. Но предположим, что поток ввода досрочно оборвался, или на входе была строка вместо числа. В таком случае конструкция `std::cin >> age` никак не изменит переменную `age`, а лишь возведёт специальный [флаг ошибки](https://en.cppreference.com/w/cpp/io/ios_base/iostate) в объекте `std::cin`. Наша переменная `age` останется непроинициализированной: в ней будет лежать неопределённый мусор. Можно было бы явно проверить этот флаг в объекте `std::cin`, но мы вместо этого включим режим генерации исключений при таких ошибках ввода:

```cpp
int ReadAge() {
    std::cin.exceptions(std::istream::failbit);
    int age;
    std::cin >> age;
    if (age < 0 || age >= 128) {
        throw WrongAgeException(age);
    }
    return age;
}
```

Теперь ошибка чтения в операторе `>>` у потока ввода будет приводить к исключению типа [`std::istream::failure`](https://en.cppreference.com/w/cpp/io/ios_base/failure). Функция `ReadAge` его не обрабатывает. Поэтому такое исключение покинет пределы этой функции. Поймаем его в функции `main`:

```cpp
int main() {
    try {
        age = ReadAge();  // может сгенерировать исключения разных типов
        // Работаем с возрастом age
    } catch (const WrongAgeException& ex) {
        std::cerr << "Age is not correct: " << ex.age << "\n";
        return 1;
    } catch (const std::istream::failure& ex) {
        std::cerr << "Failed to read age: " << ex.what() << "\n";
        return 1;
    } catch (...) {
        std::cerr << "Some other exception\n";
        return 1;
    }
    // ...
}
```

При обработке мы воспользовались функцией `ex.what` у исключения типа `std::istream::failure`. Такие функции есть у всех исключений стандартной библиотеки: они возвращают текстовое описание ошибки.

Обратите внимание на третий `catch` с многоточием. Такой блок, если он присутствует, будет перехватывать любые исключения, не перехваченные ранее.
## Исключения стандартной библиотеки

Функции и классы стандартной библиотеки в некоторых ситуациях генерируют исключения особых типов. Все такие типы выстроены в [иерархию наследования](https://en.cppreference.com/w/cpp/error/exception) от базового класса `std::exception`. Иерархия классов позволяет писать обработчик `catch` сразу на группу ошибок, которые представлены базовым классом: `std::logic_error`, `std::runtime_error` и т. д.

Вот несколько примеров:

1. Функция `at` у контейнеров `std::array`, `std::vector` и `std::deque` генерирует исключение `std::out_of_range` при некорректном индексе.
2. Аналогично, функция `at` у `std::map`, `std::unordered_map` и у соответствующих мультиконтейнеров генерирует исключение `std::out_of_range` при отсутствующем ключе.
3. Обращение к значению у пустого объекта `std::optional` приводит к исключению `std::bad_optional_access`.
4. Потоки ввода-вывода могут генерировать исключение `std::ios_base::failure`.
## Исключения в конструкторах

Ранее мы написали класс `Time`. Этот класс должен был соблюдать инвариант на значение часов, минут и секунд: они должны были быть корректными. Если на вход конструктору класса `Time` передавались некорректные значения, мы приводили их к корректным, используя деление с остатком.

Более правильным было бы сгенерировать в конструкторе исключение. Таким образом мы бы явно передали сообщение об ошибке во внешнюю функцию, которая пыталась создать объект.

```cpp
class Time {
private:
    int hours, minutes, seconds;

public:
    // Заведём класс для исключения и поместим его внутрь класса Time как в пространство имён
    class IncorrectTimeException {
    };

    Time::Time(int h, int m, int s) {
        if (s < 0 || s > 59 || m < 0 || m > 59 || h < 0 || h > 23) {
            throw IncorrectTimeException();
        }
        hours = h;
        minutes = m;
        seconds = s;
    }

    // ...
};
```

Генерировать исключения в конструкторах — совершенно нормальная практика. Однако не следует допускать, чтобы исключения покидали пределы деструкторов. Чтобы понять причины, посмотрим подробнее, что происходит при генерации исключения.
## Свёртка стека

Вспомним класс `Logger` из предыдущего параграфа. Посмотрим, как он ведёт себя при возникновении исключения. Воспользуемся в этом примере стандартным базовым классом `std::exception`, чтобы не писать свой класс исключения.

```cpp
#include <exception>
#include <iostream>

void f() {
    std::cout << "Welcome to f()!\n";
    Logger x;
    // ...
    throw std::exception();  // в какой-то момент происходит исключение
}

int main() {
    try {
        Logger y;
        f();
    } catch (const std::exception&) {
        std::cout << "Something happened...\n";
        return 1;
    }
}
```

Мы увидим такой вывод:

```
Logger(): 1
Welcome to f()!
Logger(): 2
~Logger(): 2
~Logger(): 1
Something happened...
```

Сначала создаётся объект `y` в блоке `try`. Затем мы входим в функцию `f`. В ней создаётся объект `x`. После этого происходит исключение. Мы должны досрочно покинуть функцию. В этот момент начинается _свёртка стека_ (stack unwinding): вызываются деструкторы для всех созданных объектов в самой функции и в блоке `try`, как если бы они вышли из своей области видимости. Поэтому перед обработчиком исключения мы видим вызов деструктора объекта `x`, а затем — объекта `y`.

Аналогично, свёртка стека происходит и при генерации исключения в конструкторе. Напишем класс с полем `Logger` и сгенерируем нарочно исключение в его конструкторе:

```cpp
#include <exception>
#include <iostream>

class C {
private:
    Logger x;

public:
    C() {
        std::cout << "C()\n";
        Logger y;
        // ...
        throw std::exception();
    }

    ~C() {
        std::cout << "~C()\n";
    }
};

int main() {
    try {
        C c;
    } catch (const std::exception&) {
        std::cout << "Something happened...\n";
    }
}
```

Вывод программы:

```
Logger(): 1  // конструктор поля x
C()
Logger(): 2  // конструктор локальной переменной y
~Logger(): 2  // свёртка стека: деструктор y
~Logger(): 1  // свёртка стека: деструктор поля x
Something happened...
```

Заметим, что деструктор самого класса `C` не вызывается, так как объект в конструкторе не был создан.

Механизм свёртки стека гарантирует, что деструкторы для всех созданных автоматических объектов или полей класса в любом случае будут вызваны. Однако он полагается на важное свойство: _деструкторы самих классов не должны генерировать исключений_. Если исключение в деструкторе произойдёт в момент свёртки стека при обработке другого исключения, то программа аварийно завершится.

## Пример с динамической памятью

Подчеркнём, что свёртка стека работает только с автоматическими объектами. В этом нет ничего удивительного: ведь за временем жизни объектов, созданных в динамической памяти, программист должен следить самостоятельно. Исключения вносят дополнительные сложности в ручное управление динамическими объектами:

```cpp
void f() {
    Logger* ptr = new Logger();  // конструируем объект класса Logger в динамической памяти
    // ...
    g();  // вызываем какую-то функцию
    // ...
    delete ptr;  // вызываем деструктор и очищаем динамическую память
}
```

На первый взгляд кажется, что в этом коде нет ничего опасного: `delete` вызывается в конце функции. Однако функция `g` может сгенерировать исключение. Мы не перехватываем его в нашей функции `f`. Механизм свёртки уберёт со стека лишь сам указатель `ptr`, который является автоматической переменной примитивного типа. Однако он ничего не сможет сделать с объектом в памяти, на которую ссылается этот указатель. В логе мы увидим только вызов конструктора класса `Logger`, но не увидим вызова деструктора. Нам придётся обработать исключение вручную:

```cpp
void f() {
    Logger* ptr = new Logger();
    // ...
    try {
        g();
    } catch (...) {  // ловим любое исключение
        delete ptr;  // вручную удаляем объект
        throw;  // перекидываем объект исключения дальше
    }
    // ...
    delete ptr;

}
```

Здесь мы перехватываем любое исключение и частично обрабатываем его, удаляя объект в динамической памяти. Затем мы прокидываем текущий объект исключения дальше с помощью оператора `throw` без аргументов.

Согласитесь, этот код очень далёк от совершенства. При непосредственной работе с объектами в динамической памяти нам приходится оборачивать в `try`/`catch` любую конструкцию, из которой может вылететь исключение. Понятно, что такой код чреват ошибками. 
## Гарантии безопасности исключений

Предположим, что мы пишем свой класс-контейнер, похожий на двусвязный список. Наш контейнер позволяет добавлять элементы в хранилище и отдельно хранит количество элементов в некотором поле `elementsCount`. Один из инвариантов этого класса такой: значение `elementsCount` равно реальному числу элементов в хранилище.

Не вдаваясь в детали, давайте посмотрим, как могла бы выглядеть функция добавления элемента.

```cpp
template <typename T>
class List {
private:
    struct Node {  // узел двусвязного списка
        T element;
        Node* prev = nullptr;  // предыдущий узел
        Node* next = nullptr;  // следующий узел
    };

    Node* first = nullptr;  // первый узел списка
    Node* last = nullptr;  // последний узел списка
    int elementsCount = 0;

public:
    // ...

    size_t Size() const {
        return elementsCount;
    }

    void PushBack(const T& elem) {
        ++elementsCount;

        // Конструируем в динамической памяти новой узел списка
        Node* node = new Node(elem, last, nullptr);

        // Связываем новый узел с остальными узлами
        if (last != nullptr) {
            last->next = node;
        } else {
            first = node;
        }
        last = node;
    }
};
```

Не будем здесь рассматривать другие функции класса — конструкторы, деструктор, оператор присваивания... Рассмотрим функцию `PushBack`. В ней могут произойти такие исключения:

1. Выражение `new` может сгенерировать исключение [`std::bad_alloc`](https://en.cppreference.com/w/cpp/memory/new/bad_alloc) из-за нехватки памяти.
2. Конструктор копирования класса `T` может сгенерировать произвольное исключение. Этот конструктор вызывается при инициализации поля `element` создаваемого узла в конструкторе класса `Node`. В этом случае `new` ведёт себя как транзакция: выделенная перед этим динамическая память корректно вернётся системе.

Эти исключения не перехватываются в функции `PushBack`. Их может перехватить код, из которого `PushBack` вызывался:

```cpp
#include <iostream>

class C;  // какой-то класс

int main() {
    List<C> data;
    C element;

    try {
        data.PushBack(element);
    } catch (...) {  // не получилось добавить элемент
        std::cout << data.Size() << "\n";  // внезапно 1, а не 0
    }

    // работаем дальше с data
}
```

Наша функция `PushBack` сначала увеличивает счётчик элементов, а затем выполняет опасные операции. Если происходит исключение, то в классе `List` нарушается инвариант: значение счётчика `elementsCount` перестаёт соответствовать реальности. Можно сказать, что функция `PushBack` _не даёт гарантий безопасности_.

Всего выделяют четыре уровня [_гарантий безопасности исключений_](https://en.wikipedia.org/wiki/Exception_safety) (exception safety guarantees):

1. **Гарантия отсутствия сбоев**.  
    Функции с такими гарантиями вообще не выбрасывают исключений. Примерами могут служить правильно написанные деструктор и конструктор перемещения, а также константные функции вида `Size`.
2. **Строгая гарантия безопасности**.  
    Исключение может возникнуть, но от этого объект нашего класса не поменяет состояние: количество элементов останется прежним, итераторы и ссылки не будут инвалидированы и т. д.
3. **Базовая гарантия безопасности**.  
    При исключении состояние объекта может поменяться, но оно останется внутренне согласованным, то есть, инварианты будут соблюдаться.
4. **Отсутствие гарантий**.  
    Это довольно опасная категория: при возникновении исключений могут нарушаться инварианты.

Всегда стоит разрабатывать классы, обеспечивающие хотя бы базовую гарантию безопасности. При этом не всегда возможно эффективно обеспечить строгую гарантию.

Переместим в нашей функции `PushBack` изменение счётчика в конец:

```cpp
    void PushBack(const T& elem) {
        Node* node = new Node(elem, last, nullptr);

        if (last != nullptr) {
            last->next = node;
        } else {
            first = node;
        }
        last = node;

        ++elementsCount;  // выполнится только если раньше не было исключений
    }
```

Теперь такая функция соответствует строгой гарантии безопасности.

В документации функций из классов стандартной библиотеки обычно указано, какой уровень гарантии они обеспечивают. Рассмотрим, например, гарантии безопасности класса `std::vector`.

- Деструктор, функции `empty`, `size`, `capacity`, а также `clear` предоставляют гарантию отсутствия сбоев.
- Функции `push_back` и `resize` предоставляют строгую гарантию.
- Функция `insert` предоставляет лишь базовую гарантию.

Можно было бы сделать так, чтобы она предоставляла строгую гарантию, но за это пришлось бы заплатить её эффективностью: при вставке в середину вектора пришлось бы делать реаллокацию.

Функции класса, которые гарантируют отсутствие сбоев, следует помечать ключевым словом [`noexcept`](https://en.cppreference.com/w/cpp/language/noexcept_spec):

```cpp
class C {
public:
    void f() noexcept {
        // ...
    }
};
```

С одной стороны, эта подсказка позволяет компилятору генерировать более эффективный код. С другой — эффективно обрабатывать объекты таких классов в стандартных контейнерах. Например, `std::vector<C>` при реаллокации будет использовать конструктор перемещения класса `C`, если он помечен как `noexcept`. В противном случае будет использован конструктор копирования, который может быть менее эффективен, но зато позволит обеспечить строгую гарантию безопасности при реаллокации.